<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>通过代码画时序图</title>
      <link href="/posts/50e96a11.html"/>
      <url>/posts/50e96a11.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是时序图"><a href="#什么是时序图" class="headerlink" title="什么是时序图"></a>什么是时序图</h2><p>时序图（Sequence Diagram），又名序列图、循序图，是一种UML交互图。它通过描述对象之间发送消息的时间顺序显示多个对象之间的动态协作。它可以表示用例的行为顺序，当执行一个用例行为时，其中的每条消息对应一个类操作或状态机中引起转换的触发事件。</p><h2 id="怎么通过代码画时序图"><a href="#怎么通过代码画时序图" class="headerlink" title="怎么通过代码画时序图"></a>怎么通过代码画时序图</h2><p>PlantUML是一个可以快速编写UML图的组件。PlantUML提供了一个<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">在线服务</a>，可通过在输入框中输入PlantUML语法，从而渲染出对应的时序图。</p><p>该<a href="https://www.plantuml.com/plantuml/uml/SyfFKj2rKt3CoKnELR1Io4ZDoSa70000">在线服务</a>主要区分为“代码输入”和“时序图”两个区域，通过输入的代码，服务即时渲染出时序图。</p><p><img src="https://monsterco-oss.oss-cn-shenzhen.aliyuncs.com/uPic/image-20220815221534277.png" alt="image-20220815221534277"></p><h2 id="PlantUML常用语法"><a href="#PlantUML常用语法" class="headerlink" title="PlantUML常用语法"></a>PlantUML常用语法</h2><p>基本结构，通过@startuml、@enduml定位时序图的开始和结束，在这两个符号中间编写语法从而生成书序图。</p><table><thead><tr><th align="left">符号</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td align="left">@startuml</td><td>定义起始点</td><td></td></tr><tr><td align="left">@enduml</td><td>定义结束点</td><td></td></tr><tr><td align="left">autonumber</td><td>时序图中的自动编号</td><td>配置项</td></tr><tr><td align="left">title</td><td>时序图标题</td><td>titile “微信小程序登陆”</td></tr><tr><td align="left">‘</td><td>单行注释</td><td>‘备注信息，不会影响渲染</td></tr><tr><td align="left">skinparam responseMessageBelowArrow true</td><td>响应信息显示在箭头下面</td><td>配置项</td></tr><tr><td align="left">actor</td><td>定义角色，显示图标为“角色图标”</td><td>actor user</td></tr><tr><td align="left">participant</td><td>定义参与者，显示图标为：矩形</td><td>participant “通勤找房应用”</td></tr><tr><td align="left">as</td><td>指定别名，后续语法中可使用别名简化</td><td>participant “通勤找房应用” as renting</td></tr><tr><td align="left">-&gt;</td><td>右箭头</td><td>user -&gt; renting: 输入查找关键字(keyword)</td></tr><tr><td align="left">–&gt;</td><td>左箭头（虚线）</td><td>amap –&gt; renting: 返回自动提示数据列表</td></tr><tr><td align="left">activate</td><td>激活生命线</td><td>activate user</td></tr><tr><td align="left">deactivate</td><td>终结生命线</td><td>deactivate user</td></tr><tr><td align="left">loop … end</td><td>循环</td><td>loop 根据路线名称，获取线路集合<br/>renting -&gt; amap:调用AMap.LineSearch.search()根据线路名称查询所有线路<br/>activate amap<br/>end</td></tr><tr><td align="left">&#x3D;&#x3D;</td><td>分隔符</td><td>&#x3D;&#x3D; 业务请求 &#x3D;&#x3D;</td></tr></tbody></table><h2 id="通过PlantUML绘制“微信小程序登陆”流程"><a href="#通过PlantUML绘制“微信小程序登陆”流程" class="headerlink" title="通过PlantUML绘制“微信小程序登陆”流程"></a>通过PlantUML绘制“微信小程序登陆”流程</h2><p><img src="https://monsterco-oss.oss-cn-shenzhen.aliyuncs.com/uPic/63ed4287a1db036747d874e7c624b896-20220816093141724.svg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">title &quot;微信小程序登陆时序图&quot;</span><br><span class="line">autonumber</span><br><span class="line">skinparam responseMessageBelowArrow true</span><br><span class="line"></span><br><span class="line">participant &quot;微信小程序&quot; as miniprogram</span><br><span class="line">participant &quot;开发者服务器&quot; as develop</span><br><span class="line">participant &quot;微信接口服务&quot; as Server #orange</span><br><span class="line"></span><br><span class="line">activate miniprogram</span><br><span class="line"></span><br><span class="line">miniprogram -&gt; miniprogram: wx.login()获取code</span><br><span class="line"></span><br><span class="line">miniprogram -&gt; develop: wx.request()发送code</span><br><span class="line">activate develop</span><br><span class="line"></span><br><span class="line">develop -&gt; Server: appid+appsecret+code</span><br><span class="line">activate Server</span><br><span class="line">note right of Server: 这是一个注释</span><br><span class="line"></span><br><span class="line">Server --&gt; develop: session_key+openid等</span><br><span class="line">deactivate develop</span><br><span class="line">deactivate Server</span><br><span class="line"></span><br><span class="line">develop -&gt; develop: 自定义登录态</span><br><span class="line"></span><br><span class="line">develop --&gt; miniprogram: 返回登陆态信息</span><br><span class="line">&#x27;deactivate miniprogram</span><br><span class="line"></span><br><span class="line">miniprogram -&gt; miniprogram:保存登陆态信息</span><br><span class="line"></span><br><span class="line">== 业务请求 ==</span><br><span class="line"></span><br><span class="line">miniprogram -&gt; develop: wx.request()携带登录态信息，请求业务信息</span><br><span class="line"></span><br><span class="line">develop --&gt; miniprogram: 返回业务数据</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 画图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 画图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cron表达式</title>
      <link href="/posts/6a1ed024.html"/>
      <url>/posts/6a1ed024.html</url>
      
        <content type="html"><![CDATA[<h2 id="博客地址"><a href="#博客地址" class="headerlink" title="博客地址"></a>博客地址</h2><p>欢迎关注<a href="https://monsterco.gitee.io/">博客主页</a> ，分享更多使用技巧</p><h2 id="什么是Cron表达式"><a href="#什么是Cron表达式" class="headerlink" title="什么是Cron表达式"></a>什么是Cron表达式</h2><p>如果接触过quanx、github action、云函数、linux定时任务等的应该都知道Cron表达式，如：<code>0 0 15 * * ?</code>表示每天下午3点钟执行一次</p><img src="https://i.loli.net/2021/01/26/FWHsMRphXf2eon1.png" alt="image-20210126082430289" style="zoom: 33%;" /><p>Cron可以解释为：计划任务、定时任务。这就比较好理解了，所谓定时任务，就是能够在<code>规定时间</code>内重复执行的任务。</p><p>而用于设置该<code>规定时间</code>的表达式就是Cron表达式。</p><h2 id="Cron表达式的构成"><a href="#Cron表达式的构成" class="headerlink" title="Cron表达式的构成"></a>Cron表达式的构成</h2><p>在日常生活中，我们经常用到的时间字段分别有：<code>年、月、日、时、分、秒</code>，Cron表达式也不例外，并且在该基础上拓展出<code>周（星期）</code></p><p>所以一个的Cron表达式应包含6或7个域（<code>年份可省略</code>）：</p><ul><li>秒分钟小时日期月份星期</li><li>秒分钟小时日期月份星期年份</li></ul><table><thead><tr><th>字段</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒（Seconds）</td><td>0~59整数</td><td>, - * &#x2F;   四个字符</td></tr><tr><td>分（<em>Minutes</em>）</td><td>0~59整数</td><td>, - * &#x2F;   四个字符</td></tr><tr><td>小时（<em>Hours</em>）</td><td>0~23整数</td><td>, - * &#x2F;   四个字符</td></tr><tr><td>日期（<em>DayofMonth</em>）</td><td>1~31整数（需要考虑当年具体月份的天数）</td><td>,- * ? &#x2F; L W C   八个字符</td></tr><tr><td>月份（<em>Month</em>）</td><td>1~12整数或者 JAN-DEC</td><td>, - * &#x2F;   四个字符</td></tr><tr><td>星期（<em>DayofWeek</em>）</td><td>1~7整数或者 SUN-SAT （1表示星期天，国外以周日为一周开始）</td><td>, - * ? &#x2F; L C #   八个字符</td></tr><tr><td>年（<em>Year</em>）（可选）</td><td>1970~2099</td><td>, - * &#x2F;   四个字符</td></tr></tbody></table><h2 id="Cron表达式中的特殊符号"><a href="#Cron表达式中的特殊符号" class="headerlink" title="Cron表达式中的特殊符号"></a>Cron表达式中的特殊符号</h2><p>根据常识，如Cron表达式中的<code>秒</code>的范围可以用<code>0-59</code>的整数表示，可是该如何表示<code>每一秒</code>呢？因此，Cron表达式中定义了一些特殊符号。</p><ul><li><code>,</code> : 表示枚举。如：在<code>分钟</code>当中使用，<code>10,20</code>表示每10分和20分各执行一次</li><li><code>-</code> :表示范围。如：在<code>分钟</code>当中使用，<code>10-20</code>表示10分到20分每分钟执行一次</li><li><code>*</code>:表示任意值。如：在<code>分钟</code>当中使用，<code>*</code>表示每分钟执行一次</li><li><code>/</code>:表示开始触发时间，然后隔固定时间执行一次。如在<code>分钟</code>当中使用，<code>5/10</code>表示从5分开始，每隔10分钟执行一次</li><li><code>?</code>:只能用在<code>日期和星期</code>，也表示匹配任意值。因为日期和星期是互相影响的，比如1月26日是周二，而不能是周三</li><li><code>L</code>:只能用在<code>日期和星期</code>，表示最后。如：在<code>月份</code>当中使用，<code>L</code>表示每个月的最后一天执行一次</li><li><code>W</code>：只能用在<code>日期</code>，表示有效工作日（周一到周五），将在指定日期最近的工作日执行一次</li><li><code>LW</code>：只能用在<code>日期</code>，可以一起使用，表示某个月最后的一个工作日</li><li><code>#</code>:只能用在<code>星期</code>，表示每个月的第几个星期几。如：<code>4#2</code>表示，某个月的第2个星期三执行一次（再次说明国外是以周日为一周的开始，所以4-1&#x3D;3是代表周三）</li></ul><h2 id="Cron表达式例子"><a href="#Cron表达式例子" class="headerlink" title="Cron表达式例子"></a>Cron表达式例子</h2><p>如果阅读完以上的说明还不是特别明白，可以结合下面具体的例子就能够理解了。</p><p>　　（0）<strong>0&#x2F;20 * * * * ?</strong>  表示每20秒 调整任务</p><p>　　（1）<strong>0 0 2 1 * ?</strong>  表示在每月的1日的凌晨2点调整任务</p><p>　　（2）<strong>0 15 10 ? * MON-FRI</strong>  表示周一到周五每天上午10:15执行作业</p><p>　　（3）<strong>0 15 10 ? 6L 2002-2006</strong>  表示2002-2006年的每个月的最后一个星期五上午10:15执行作</p><p>　　（4）<strong>0 0 10,14,16 * * ?</strong>  每天上午10点，下午2点，4点 </p><p>　　（5）<strong>0 0&#x2F;30 9-17 * * ?</strong>  朝九晚五工作时间内每半小时 </p><p>　　（6）<strong>0 0 12 ? * WED</strong>   表示每个星期三中午12点 </p><p>　　（7）<strong>0 0 12 * * ?</strong>  每天中午12点触发 </p><p>　　（8）<strong>0 15 10 ? * *</strong>   每天上午10:15触发 </p><p>　　（9）<strong>0 15 10 * * ?</strong>   每天上午10:15触发 </p><p>　　（10）<strong>0 15 10 * * ? *</strong>   每天上午10:15触发 </p><p>　　（11）<strong>0 15 10 * * ? 2005</strong>   2005年的每天上午10:15触发 </p><p>　　（12）<strong>0 * 14 * * ?</strong>   在每天下午2点到下午2:59期间的每1分钟触发 </p><p>　　（13）<strong>0 0&#x2F;5 14 * * ?</strong>   在每天下午2点到下午2:55期间的每5分钟触发 </p><p>　　（14）<strong>0 0&#x2F;5 14,18 * * ?</strong>   在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </p><p>　　（15）<strong>0 0-5 14 * * ?</strong>   在每天下午2点到下午2:05期间的每1分钟触发 </p><p>　　（16）<strong>0 10,44 14 ? 3 WED</strong>   每年三月的星期三的下午2:10和2:44触发 </p><p>　　（17）<strong>0 15 10 ? * MON-FRI</strong>   周一至周五的上午10:15触发 </p><p>　　（18）<strong>0 15 10 15 * ?</strong>   每月15日上午10:15触发 </p><p>　　（19）<strong>0 15 10 L * ?</strong>   每月最后一日的上午10:15触发 </p><p>　　（20）<strong>0 15 10 ? * 6L</strong>   每月的最后一个星期五上午10:15触发 </p><p>　　（21）<strong>0 15 10 ? * 6L 2002-2005</strong>  2002年至2005年的每月的最后一个星期五上午10:15触发 </p><p>　　（22）<strong>0 15 10 ? * 6#3</strong>  每月的第三个星期五上午10:15触发</p><h2 id="Github-Action中的Cron表达式"><a href="#Github-Action中的Cron表达式" class="headerlink" title="Github Action中的Cron表达式"></a>Github Action中的Cron表达式</h2><p>这里需要特别注意，Github Action中的Cron是没有<code>秒</code>的概念的，并且时间是<code>国际时间</code>，相比于北京时间<code>相差8小时</code></p><p>如：<code>10 12 * * *</code>表示每天下午8点10分执行 （12 + 8 &#x3D; 20）</p><p>感兴趣可以阅读<a href="https://docs.github.com/en/actions/reference/events-that-trigger-workflows#scheduled-events-schedule">Github Doc</a></p><img src="https://i.loli.net/2021/01/26/u6B51tDYHFw2Mjz.png" alt="image-20210126085641756" style="zoom: 33%;" />]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cron表达式 </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github工作流自动签到获取京豆</title>
      <link href="/posts/f360eb4.html"/>
      <url>/posts/f360eb4.html</url>
      
        <content type="html"><![CDATA[<p>博客地址：<a href="https://monsterco.gitee.io/">https://monsterco.gitee.io/</a></p><p>本操作教程基于Github Action工作流，无需使用手机、软件等，请放心食用。</p><p>前提：</p><ul><li><input checked="" disabled="" type="checkbox"> Github账号（<a href="https://github.com/%EF%BC%89">https://github.com/）</a></li><li><input checked="" disabled="" type="checkbox"> 某东账号（以某东为例）</li><li><input disabled="" type="checkbox"> Sever酱（非必要条件，使用来签到后推送通知用的）</li></ul><h2 id="获取账号cookie（以某东为例）"><a href="#获取账号cookie（以某东为例）" class="headerlink" title="获取账号cookie（以某东为例）"></a>获取账号cookie（以某东为例）</h2><p>使用电脑操作，打开<a href="https://bean.m.jd.com/">打开京东签到页面</a>，登陆自己的账号后，打开浏览器开发者界面（键盘按F12），切换到<code>Application</code>选项，左侧选择<code>cookies</code>，并在右侧找到<code>pt_key</code>和<code>pt_pin</code>，复制对应的值，拼接成<code>pt_key=****;pt_pin=***</code>格式保存起来备用</p><p><img src="https://i.loli.net/2021/01/15/WiL7dVCETgXlep9.png" alt="image-20210115162055276"></p><h2 id="打开博客，进入项目"><a href="#打开博客，进入项目" class="headerlink" title="打开博客，进入项目"></a>打开博客，进入项目</h2><p><img src="https://i.loli.net/2021/01/15/Rmn2jvquacSLdJe.png" alt="image-20210115151559926"></p><p><img src="https://i.loli.net/2021/01/15/9KrI2RXQ5EnApqv.png" alt="image-20210115151900748"></p><p>以图上箭头所示（某东：Mons0512&#x2F;MyActions）为例，是当前最全的京豆自动签到脚本，也是我当前在用的脚本，包括每日签到、某东农场、某东萌宠等能够获取京豆的模块。至于京豆能够用来干嘛，请参考<a href="https://baike.baidu.com/item/%E4%BA%AC%E8%B1%86/12022282?fr=kg_qa">百科</a>，简单说，就是在结算时能够减免金额，甚至某些模块里面还能免费领取水果等操作。</p><h2 id="Github操作"><a href="#Github操作" class="headerlink" title="Github操作"></a>Github操作</h2><p>1.在Github中fork当前项目（可以理解为复制当前项目），这样你的账号就有了这个项目，可以对项目进行修改</p><p><img src="https://i.loli.net/2021/01/15/GPeF7WJqRnLjrK6.png" alt="image-20210115152747652"></p><p>2.点击settings并配置secrets（配置某东账号信息、server酱通知推送信息等）</p><p><img src="https://i.loli.net/2021/01/15/Mhn3aRZrNbYQGlw.png" alt="image-20210115160434188"></p><p>3.配置cookie，此处的secret配置后所有人都无法查看，甚至是自己的账号，添加后只能更新和删除，请放心填写</p><p><img src="https://i.loli.net/2021/01/15/k5h3fKNZHVlpGuA.png" alt="image-20210115163721933"></p><h2 id="启动Github-Action工作流"><a href="#启动Github-Action工作流" class="headerlink" title="启动Github Action工作流"></a>启动Github Action工作流</h2><p>切换到<code>Actions</code>，确认开启工作流</p><p><img src="https://i.loli.net/2021/01/15/THl7xCWEgtiIokD.png" alt="image-20210115164548613"></p><p>此时还没运行工作流，需要手动启动一次：</p><p>1.点击右上角<code>Star</code>触发</p><p><img src="https://i.loli.net/2021/01/15/qJdKPZWQVNOe4oU.png" alt="image-20210115164910086"></p><p>2.修改ReadMe.md文件触发</p><p>切换到<code>Code</code>，点击图示中的修改按钮，在输入框最后随便添加一些内容并填写修改信息之后点击提交（commit changes）</p><p><img src="https://i.loli.net/2021/01/15/QHejgD42NaXc6sR.png" alt="image-20210115164948944"></p><p><img src="https://i.loli.net/2021/01/15/sWq5HYwcDovhKVI.png" alt="image-20210115165121550"></p><p>3.此时工作流就已经开始自动运行了，可以在<code>Actions</code>中查看运行情况</p><p><img src="https://i.loli.net/2021/01/15/nVHyTeIpAc5FsKJ.png" alt="image-20210115165433001"></p><p><img src="https://i.loli.net/2021/01/15/HvGxNutdjfaAYoh.png" alt="image-20210115170024739"></p><p><img src="https://i.loli.net/2021/01/15/b5N9tQzHVBCy6vs.png" alt="image-20210115170049194"></p><h2 id="配置server酱推送（非必须，配置后可推送签到情况）"><a href="#配置server酱推送（非必须，配置后可推送签到情况）" class="headerlink" title="配置server酱推送（非必须，配置后可推送签到情况）"></a>配置server酱推送（非必须，配置后可推送签到情况）</h2><p>如图，是配置了消息推送后，server酱推送到WX的签到情况</p><img src="https://i.loli.net/2021/01/15/BhiosuXtD81SLUc.png" alt="IMG_7463" style="zoom:25%;" /><p>此步为非必须操作，如果想要将签到的情况发送到WX等，可以根据以下操作进行</p><p>1.登陆server酱跳转Github授权，并配置微信推送，配置成功后会获得一串秘钥，复制备用</p><p><img src="https://i.loli.net/2021/01/15/6Y2cNr1xoAJBTLD.png" alt="image-20210115161119755"></p><p>2.参照上一步，在github项目settgings的secrets中配置推送</p><p><img src="https://i.loli.net/2021/01/15/BTQlC3UwWIZkpjh.png" alt="image-20210115161556361"></p><h2 id="说在最后"><a href="#说在最后" class="headerlink" title="说在最后"></a>说在最后</h2><p>该教程只是以该Github项目为例进行操作讲解，具体其他项目的操作大同小异，<code>不同的是settings中填写的secrets</code></p><p>每过一个月 <code>Cookie</code> 会过期，所以要定时去记得更新你的 <code>Secrets</code> 中的 <code>JD_COOKIE</code>, 否则，程序不能正常运行</p><p>相对于其他自动签到的方法，比如使用<code>圈x和小火箭</code>等，通过手机进行操作，相对没有这么简单并且购买这些软件是需要付费并且目前仅仅只有IOS端。相对而言，此教程的是目前比较好的方案。</p><p>如果操作上有问题的可以扫描博客首页二维码，添加微信号和添加站长微信咨询。</p>]]></content>
      
      
      <categories>
          
          <category> 薅羊毛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github Action </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES的分布式架构原理是什么？</title>
      <link href="/posts/61431281.html"/>
      <url>/posts/61431281.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES的分布式架构原理是什么？"><a href="#ES的分布式架构原理是什么？" class="headerlink" title="ES的分布式架构原理是什么？"></a>ES的分布式架构原理是什么？</h1><p>在搜索这块，lucene 是最流行的搜索库。几年前业内一般都问，你了解 lucene 吗？你知道倒排索引的原理吗？现在早已经 out 了，因为现在很多项目都是直接用基于 lucene 的分布式搜索引擎—— ElasticSearch，简称为 ES。</p><p>而现在分布式搜索基本已经成为大部分互联网行业的 Java 系统的标配，其中尤为流行的就是 ES，前几年 ES 没火的时候，大家一般用 solr。但是这两年基本大部分企业和项目都开始转向 ES 了。</p><p>所以互联网面试，肯定会跟你聊聊分布式搜索引擎，也就一定会聊聊 ES，如果你确实不知道，那你真的就 out 了。</p><p>如果面试官问你第一个问题，确实一般都会问你 ES 的分布式架构设计能介绍一下么？就看看你对分布式搜索引擎架构的一个基本理解。</p><h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>ElasticSearch 设计的理念就是分布式搜索引擎，<code>底层基于 lucene</code> 。核心思想就是在多台机器上启动多个 ES 进程实例，组成了一个 ES 集群。</p><p>ES 中存储数据的<strong>基本单位是索引</strong>，比如说你现在要在 ES 中存储一些订单数据，你就应该在 ES 中创建一个索引 <code>order_idx</code> ，所有的订单数据就都写到这个索引里面去，一个索引差不多就是相当于是 mysql 里的一张表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index -&gt; type -&gt; mapping -&gt; document -&gt; field。</span><br></pre></td></tr></table></figure><p>这样吧，为了做个更直白的介绍，我在这里做个类比。但是切记，不要划等号，类比只是为了便于理解。</p><p>index 相当于 mysql 里的一张表。而 type 没法跟 mysql 里去对比，一个 index 里可以有多个 type，每个 type 的字段都是差不多的，但是有一些略微的差别。假设有一个 index，是订单 index，里面专门是放订单数据的。就好比说你在 mysql 中建表，有些订单是实物商品的订单，比如一件衣服、一双鞋子；有些订单是虚拟商品的订单，比如游戏点卡，话费充值。就两种订单大部分字段是一样的，但是少部分字段可能有略微的一些差别。</p><p>所以就会在订单 index 里，建两个 type，一个是实物商品订单 type，一个是虚拟商品订单 type，这两个 type 大部分字段是一样的，少部分字段是不一样的。</p><p>很多情况下，一个 index 里可能就一个 type，但是确实如果说是一个 index 里有多个 type 的情况（<strong>注意</strong>， <code>mapping types</code> 这个概念在 ElasticSearch 7. X 已被完全移除，详细说明可以参考<a href="https://github.com/elastic/elasticsearch/blob/6.5/docs/reference/mapping/removal_of_types.asciidoc">官方文档</a>），你可以认为 index 是一个类别的表，具体的每个 type 代表了 mysql 中的一个表。每个 type 有一个 mapping，如果你认为一个 type 是具体的一个表，index 就代表多个 type 同属于的一个类型，而 mapping 就是这个 type 的<strong>表结构定义</strong>，你在 mysql 中创建一个表，肯定是要定义表结构的，里面有哪些字段，每个字段是什么类型。实际上你往 index 里的一个 type 里面写的一条数据，叫做一条 document，一条 document 就代表了 mysql 中某个表里的一行，每个 document 有多个 field，每个 field 就代表了这个 document 中的一个字段的值。<img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/es-index-type-mapping-document-field.png" alt="es-index-type-mapping-document-field" style="zoom:67%;" /></p><p>你搞一个索引，这个索引可以拆分成多个 <code>shard</code> ，每个 shard 存储部分数据。拆分多个 shard 是有好处的，一是<strong>支持横向扩展</strong>，比如你数据量是 3T，3 个 shard，每个 shard 就 1T 的数据，若现在数据量增加到 4T，怎么扩展，很简单，重新建一个有 4 个 shard 的索引，将数据导进去；二是<strong>提高性能</strong>，数据分布在多个 shard，即多台服务器上，所有的操作，都会在多台机器上并行分布式执行，提高了吞吐量和性能。</p><p>接着就是这个 shard 的数据实际是有多个备份，就是说每个 shard 都有一个 <code>primary shard</code> ，负责写入数据，但是还有几个 <code>replica shard</code> 。 <code>primary shard</code> 写入数据之后，会将数据同步到其他几个 <code>replica shard</code> 上去。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/es-cluster.png" alt="es-cluster" style="zoom:67%;" /><p>通过这个 replica 的方案，每个 shard 的数据都有多个备份，如果某个机器宕机了，没关系啊，还有别的数据副本在别的机器上呢。高可用了吧。</p><p>ES 集群多个节点，会自动选举一个节点为 master 节点，这个 master 节点其实就是干一些管理的工作的，比如维护索引元数据、负责切换 primary shard 和 replica shard 身份等。要是 master 节点宕机了，那么会重新选举一个节点为 master 节点。</p><p>如果是非 master 节点宕机了，那么会由 master 节点，让那个宕机节点上的 primary shard 的身份转移到其他机器上的 replica shard。接着你要是修复了那个宕机机器，重启了之后，master 节点会控制将缺失的 replica shard 分配过去，同步后续修改的数据之类的，让集群恢复正常。</p><p>说得更简单一点，就是说如果某个非 master 节点宕机了。那么此节点上的 primary shard 不就没了。那好，master 会让 primary shard 对应的 replica shard（在其他机器上）切换为 primary shard。如果宕机的机器修复了，修复后的节点也不再是 primary shard，而是 replica shard。</p><p>其实上述就是 ElasticSearch 作为分布式搜索引擎最基本的一个架构设计。</p>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES写入数据的原理是什么？</title>
      <link href="/posts/fdab4ef2.html"/>
      <url>/posts/fdab4ef2.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES写入数据的原理是什么？"><a href="#ES写入数据的原理是什么？" class="headerlink" title="ES写入数据的原理是什么？"></a>ES写入数据的原理是什么？</h1><h2 id="ES写入数据过程"><a href="#ES写入数据过程" class="headerlink" title="ES写入数据过程"></a>ES写入数据过程</h2><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是 <code>coordinating node</code> （协调节点）。</li><li><code>coordinating node</code> 对 document 进行<strong>路由</strong>，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的 <code>primary shard</code> 处理请求，然后将数据同步到 <code>replica node</code> 。</li><li><code>coordinating node</code> 如果发现 <code>primary node</code> 和所有 <code>replica node</code> 都搞定之后，就返回响应结果给客户端。</li></ul><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/es-write.png" alt="es-write" style="zoom:67%;" /><h2 id="ES读取数据过程"><a href="#ES读取数据过程" class="headerlink" title="ES读取数据过程"></a>ES读取数据过程</h2><p>可以通过 <code>doc id</code> 来查询，会根据 <code>doc id</code> 进行 hash，判断出来当时把 <code>doc id</code> 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到<strong>任意</strong>一个 node，成为 <code>coordinate node</code> 。</li><li><code>coordinate node</code> 对 <code>doc id</code> 进行哈希路由，将请求转发到对应的 node，此时会使用 <code>round-robin</code> <strong>随机轮询算法</strong>，在 <code>primary shard</code> 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 <code>coordinate node</code> 。</li><li><code>coordinate node</code> 返回 document 给客户端。</li></ul><h2 id="ES搜索数据过程"><a href="#ES搜索数据过程" class="headerlink" title="ES搜索数据过程"></a>ES搜索数据过程</h2><p>es 最强大的是做全文检索，就是比如你有三条数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java真好玩儿啊</span><br><span class="line">java好难学啊</span><br><span class="line">j2ee特别牛Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure><p>你根据 <code>java</code> 关键词来搜索，将包含 <code>java</code> 的 <code>document</code> 给搜索出来。es 就会给你返回：java 真好玩儿啊，java 好难学啊。</p><ul><li>客户端发送请求到一个 <code>coordinate node</code> 。</li><li>协调节点将搜索请求转发到<strong>所有</strong>的 shard 对应的 <code>primary shard</code> 或 <code>replica shard</code> ，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些 <code>doc id</code> ）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>fetch phase：接着由协调节点根据 <code>doc id</code> 去各个节点上<strong>拉取实际</strong>的 <code>document</code> 数据，最终返回给客户端。</li></ul><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p><h2 id="ES写数据底层原理"><a href="#ES写数据底层原理" class="headerlink" title="ES写数据底层原理"></a>ES写数据底层原理</h2><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/es-write-detail.png" alt="es-write-detail" style="zoom:67%;" /><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据 <code>refresh</code> 到一个新的 <code>segment file</code> 中，但是此时数据不是直接进入 <code>segment file</code> 磁盘文件，而是先进入 <code>os cache</code> 。这个过程就是 <code>refresh</code> 。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个<strong>新的</strong> <code>segment file</code> ，每秒钟会产生一个<strong>新的磁盘文件</strong> <code>segment file</code> ，这个 <code>segment file</code> 中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p>操作系统里面，磁盘文件其实都有一个东西，叫做 <code>os cache</code> ，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入 <code>os cache</code> ，先进入操作系统级别的一个内存缓存中去。只要 <code>buffer</code> 中的数据被 refresh 操作刷入 <code>os cache</code> 中，这个数据就可以被搜索到了。</p><p>为什么叫 es 是<strong>准实时</strong>的？ <code>NRT</code> ，全称 <code>near real-time</code> 。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的 <code>restful api</code> 或者 <code>java api</code> ，<strong>手动</strong>执行一次 refresh 操作，就是手动将 buffer 中的数据刷入 <code>os cache</code> 中，让数据立马就可以被搜索到。只要数据被输入 <code>os cache</code> 中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p><p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将 <code>buffer</code> 数据写入一个又一个新的 <code>segment file</code> 中去，每次 <code>refresh</code> 完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发 <code>commit</code> 操作。</p><p>commit 操作发生第一步，就是将 buffer 中现有数据 <code>refresh</code> 到 <code>os cache</code> 中去，清空 buffer。然后，将一个 <code>commit point</code> 写入磁盘文件，里面标识着这个 <code>commit point</code> 对应的所有 <code>segment file</code> ，同时强行将 <code>os cache</code> 中目前所有的数据都 <code>fsync</code> 到磁盘文件中去。最后<strong>清空</strong> 现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p><p>这个 commit 操作叫做 <code>flush</code> 。默认 30 分钟自动执行一次 <code>flush</code> ，但如果 translog 过大，也会触发 <code>flush</code> 。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p><p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件 <code>translog</code> 中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p><p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会<strong>丢失</strong> 5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接 <code>fsync</code> 到磁盘，但是性能会差很多。</p><p>实际上你在这里，如果面试官没有问你 es 丢数据的问题，你可以在这里给面试官炫一把，你说，其实 es 第一是准实时的，数据写入 1 秒后可以搜索到；可能会丢失数据的。有 5 秒的数据，停留在 buffer、translog os cache、segment file os cache 中，而不在磁盘上，此时如果宕机，会导致 5 秒的<strong>数据丢失</strong>。</p><p><strong>总结一下</strong>，数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p><p>数据写入 segment file 之后，同时就建立好了倒排索引。</p><h2 id="ES删除-更新数据底层原理"><a href="#ES删除-更新数据底层原理" class="headerlink" title="ES删除&#x2F;更新数据底层原理"></a>ES删除&#x2F;更新数据底层原理</h2><p>如果是删除操作，commit 的时候会生成一个 <code>.del</code> 文件，里面将某个 doc 标识为 <code>deleted</code> 状态，那么搜索的时候根据 <code>.del</code> 文件就知道这个 doc 是否被删除了。</p><p>如果是更新操作，就是将原来的 doc 标识为 <code>deleted</code> 状态，然后新写入一条数据。</p><p>buffer 每 refresh 一次，就会产生一个 <code>segment file</code> ，所以默认情况下是 1 秒钟一个 <code>segment file</code> ，这样下来 <code>segment file</code> 会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个 <code>segment file</code> 合并成一个，同时这里会将标识为 <code>deleted</code> 的 doc 给<strong>物理删除掉</strong>，然后将新的 <code>segment file</code> 写入磁盘，这里会写一个 <code>commit point</code> ，标识所有新的 <code>segment file</code> ，然后打开 <code>segment file</code> 供搜索使用，同时删除旧的 <code>segment file</code> 。</p><h2 id="底层Lucene"><a href="#底层Lucene" class="headerlink" title="底层Lucene"></a>底层Lucene</h2><p>简单来说，lucene 就是一个 jar 包，里面包含了封装好的各种建立倒排索引的算法代码。我们用 Java 开发的时候，引入 lucene jar，然后基于 lucene 的 api 去开发就可以了。</p><p>通过 lucene，我们可以将已有的数据建立索引，lucene 会在本地磁盘上面，给我们组织索引的数据结构。</p><h2 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h2><p>在搜索引擎中，每个文档都有一个对应的文档 ID，文档内容被表示为一系列关键词的集合。例如，文档 1 经过分词，提取了 20 个关键词，每个关键词都会记录它在文档中出现的次数和出现位置。</p><p>那么，倒排索引就是<strong>关键词到文档</strong> ID 的映射，每个关键词都对应着一系列的文件，这些文件中都出现了关键词。</p><p>举个栗子。</p><p>有以下文档：</p><table><thead><tr><th>DocId</th><th>Doc</th></tr></thead><tbody><tr><td>1</td><td>谷歌地图之父跳槽 Facebook</td></tr><tr><td>2</td><td>谷歌地图之父加盟 Facebook</td></tr><tr><td>3</td><td>谷歌地图创始人拉斯离开谷歌加盟 Facebook</td></tr><tr><td>4</td><td>谷歌地图之父跳槽 Facebook 与 Wave 项目取消有关</td></tr><tr><td>5</td><td>谷歌地图之父拉斯加盟社交网站 Facebook</td></tr></tbody></table><p>对文档进行分词之后，得到以下<strong>倒排索引</strong>。</p><table><thead><tr><th>WordId</th><th>Word</th><th>DocIds</th></tr></thead><tbody><tr><td>1</td><td>谷歌</td><td>1, 2, 3, 4, 5</td></tr><tr><td>2</td><td>地图</td><td>1, 2, 3, 4, 5</td></tr><tr><td>3</td><td>之父</td><td>1, 2, 4, 5</td></tr><tr><td>4</td><td>跳槽</td><td>1, 4</td></tr><tr><td>5</td><td>Facebook</td><td>1, 2, 3, 4, 5</td></tr><tr><td>6</td><td>加盟</td><td>2, 3, 5</td></tr><tr><td>7</td><td>创始人</td><td>3</td></tr><tr><td>8</td><td>拉斯</td><td>3, 5</td></tr><tr><td>9</td><td>离开</td><td>3</td></tr><tr><td>10</td><td>与</td><td>4</td></tr><tr><td>..</td><td>..</td><td>..</td></tr></tbody></table><p>另外，实用的倒排索引还可以记录更多的信息，比如文档频率信息，表示在文档集合中有多少个文档包含某个单词。</p><p>那么，有了倒排索引，搜索引擎可以很方便地响应用户的查询。比如用户输入查询 <code>Facebook</code> ，搜索系统查找倒排索引，从中读出包含这个单词的文档，这些文档就是提供给用户的搜索结果。</p><p>要注意倒排索引的两个重要细节：</p><ul><li>倒排索引中的所有词项对应一个或多个文档；</li><li>倒排索引中的词项<strong>根据字典顺序升序排列</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES如何提高查询效率？</title>
      <link href="/posts/b7e9a660.html"/>
      <url>/posts/b7e9a660.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES如何提高查询效率？"><a href="#ES如何提高查询效率？" class="headerlink" title="ES如何提高查询效率？"></a>ES如何提高查询效率？</h1><p>这个问题是肯定要问的，说白了，就是看你有没有实际干过 es，因为啥？其实 es 性能并没有你想象中那么好的。很多时候数据量大了，特别是有几亿条数据的时候，可能你会懵逼的发现，跑个搜索怎么一下 <code>5~10s</code> ，坑爹了。第一次搜索的时候，是 <code>5~10s</code> ，后面反而就快了，可能就几百毫秒。</p><p>你就很懵，每个用户第一次访问都会比较慢，比较卡么？所以你要是没玩儿过 es，或者就是自己玩玩儿 demo，被问到这个问题容易懵逼，显示出你对 es 确实玩儿的不怎么样？</p><p>说实话，es 性能优化是没有什么银弹的，啥意思呢？就是<strong>不要期待着随手调一个参数，就可以万能的应对所有的性能慢的场景</strong>。也许有的场景是你换个参数，或者调整一下语法，就可以搞定，但是绝对不是所有场景都可以这样。</p><h2 id="性能优化的杀手锏——filesystem-cache"><a href="#性能优化的杀手锏——filesystem-cache" class="headerlink" title="性能优化的杀手锏——filesystem cache"></a>性能优化的杀手锏——filesystem cache</h2><p>你往 es 里写的数据，实际上都写到磁盘文件里去了，<strong>查询的时候</strong>，操作系统会将磁盘文件里的数据自动缓存到 <code>filesystem cache</code> 里面去。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/es-search-process.png" alt="es-search-process" style="zoom:67%;" /><p>es 的搜索引擎严重依赖于底层的 <code>filesystem cache</code> ，你如果给 <code>filesystem cache</code> 更多的内存，尽量让内存可以容纳所有的 <code>idx segment file </code> 索引数据文件，那么你搜索的时候就基本都是走内存的，性能会非常高。</p><p>性能差距究竟可以有多大？我们之前很多的测试和压测，如果走磁盘一般肯定上秒，搜索性能绝对是秒级别的，1 秒、5 秒、10 秒。但如果是走 <code>filesystem cache</code> ，是走纯内存的，那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。</p><p>这里有个真实的案例。某个公司 es 节点有 3 台机器，每台机器看起来内存很多，64G，总内存就是 <code>64 * 3 = 192G</code> 。每台机器给 es jvm heap 是 <code>32G</code> ，那么剩下来留给 <code>filesystem cache</code> 的就是每台机器才 <code>32G</code> ，总共集群里给 <code>filesystem cache</code> 的就是 <code>32 * 3 = 96G</code> 内存。而此时，整个磁盘上索引数据文件，在 3 台机器上一共占用了 <code>1T</code> 的磁盘容量，es 数据量是 <code>1T</code> ，那么每台机器的数据量是 <code>300G</code> 。这样性能好吗？ <code>filesystem cache</code> 的内存才 100G，十分之一的数据可以放内存，其他的都在磁盘，然后你执行搜索操作，大部分操作都是走磁盘，性能肯定差。</p><p>归根结底，你要让 es 性能要好，最佳的情况下，就是你的机器的内存，至少可以容纳你的总数据量的一半。</p><p>根据我们自己的生产环境实践经验，最佳的情况下，是仅仅在 es 中就存少量的数据，就是你要<strong>用来搜索的那些索引</strong>，如果内存留给 <code>filesystem cache</code> 的是 100G，那么你就将索引数据控制在 <code>100G</code> 以内，这样的话，你的数据几乎全部走内存来搜索，性能非常之高，一般可以在 1 秒以内。</p><p>比如说你现在有一行数据。 <code>id,name,age ....</code> 30 个字段。但是你现在搜索，只需要根据 <code>id,name,age</code> 三个字段来搜索。如果你傻乎乎往 es 里写入一行数据所有的字段，就会导致说 <code>90%</code> 的数据是不用来搜索的，结果硬是占据了 es 机器上的 <code>filesystem cache</code> 的空间，单条数据的数据量越大，就会导致 <code>filesystem cahce</code> 能缓存的数据就越少。其实，仅仅写入 es 中要用来检索的<strong>少数几个字段</strong>就可以了，比如说就写入 es <code>id,name,age</code> 三个字段，然后你可以把其他的字段数据存在 mysql&#x2F;hbase 里，我们一般是建议用 <code>es + hbase</code> 这么一个架构。</p><p>hbase 的特点是<strong>适用于海量数据的在线存储</strong>，就是对 hbase 可以写入海量数据，但是不要做复杂的搜索，做很简单的一些根据 id 或者范围进行查询的这么一个操作就可以了。从 es 中根据 name 和 age 去搜索，拿到的结果可能就 20 个 <code>doc id</code> ，然后根据 <code>doc id</code> 到 hbase 里去查询每个 <code>doc id</code> 对应的<strong>完整的数据</strong>，给查出来，再返回给前端。</p><p>写入 es 的数据最好小于等于，或者是略微大于 es 的 filesystem cache 的内存容量。然后你从 es 检索可能就花费 20ms，然后再根据 es 返回的 id 去 hbase 里查询，查 20 条数据，可能也就耗费个 30ms，可能你原来那么玩儿，1T 数据都放 es，会每次查询都是 5~10s，现在可能性能就会很高，每次查询就是 50ms。</p><h2 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h2><p>假如说，哪怕是你就按照上述的方案去做了，es 集群中每个机器写入的数据量还是超过了 <code>filesystem cache</code> 一倍，比如说你写入一台机器 60G 数据，结果 <code>filesystem cache</code> 就 30G，还是有 30G 数据留在了磁盘上。</p><p>其实可以做<strong>数据预热</strong>。</p><p>举个例子，拿微博来说，你可以把一些大 V，平时看的人很多的数据，你自己提前后台搞个系统，每隔一会儿，自己的后台系统去搜索一下热数据，刷到 <code>filesystem cache</code> 里去，后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，很快。</p><p>或者是电商，你可以将平时查看最多的一些商品，比如说 iphone 8，热数据提前后台搞个程序，每隔 1 分钟自己主动访问一次，刷到 <code>filesystem cache</code> 里去。</p><p>对于那些你觉得比较热的、经常会有人访问的数据，最好<strong>做一个专门的缓存预热子系统</strong>，就是对热数据每隔一段时间，就提前访问一下，让数据进入 <code>filesystem cache</code> 里面去。这样下次别人访问的时候，性能一定会好很多。</p><h2 id="冷热分离"><a href="#冷热分离" class="headerlink" title="冷热分离"></a>冷热分离</h2><p>es 可以做类似于 mysql 的水平拆分，就是说将大量的访问很少、频率很低的数据，单独写一个索引，然后将访问很频繁的热数据单独写一个索引。最好是将<strong>冷数据写入一个索引中，然后热数据写入另外一个索引中</strong>，这样可以确保热数据在被预热之后，尽量都让他们留在 <code>filesystem os cache</code> 里，<strong>别让冷数据给冲刷掉</strong>。</p><p>你看，假设你有 6 台机器，2 个索引，一个放冷数据，一个放热数据，每个索引 3 个 shard。3 台机器放热数据 index，另外 3 台机器放冷数据 index。然后这样的话，你大量的时间是在访问热数据 index，热数据可能就占总数据量的 10%，此时数据量很少，几乎全都保留在 <code>filesystem cache</code> 里面了，就可以确保热数据的访问性能是很高的。但是对于冷数据而言，是在别的 index 里的，跟热数据 index 不在相同的机器上，大家互相之间都没什么联系了。如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点，就 10% 的人去访问冷数据，90% 的人在访问热数据，也无所谓了。</p><h2 id="Document模型设计"><a href="#Document模型设计" class="headerlink" title="Document模型设计"></a>Document模型设计</h2><p>对于 MySQL，我们经常有一些复杂的关联查询。在 es 里该怎么玩儿，es 里面的复杂的关联查询尽量别用，一旦用了性能一般都不太好。</p><p>最好是先在 Java 系统里就完成关联，将关联好的数据直接写入 es 中。搜索的时候，就不需要利用 es 的搜索语法来完成 join 之类的关联搜索了。</p><p>document 模型设计是非常重要的，很多操作，不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es 能支持的操作就那么多，不要考虑用 es 做一些它不好操作的事情。如果真的有那种操作，尽量在 document 模型设计的时候，写入的时候就完成。另外对于一些太复杂的操作，比如 join&#x2F;nested&#x2F;parent-child 搜索都要尽量避免，性能都很差的。</p><h2 id="分页性能优化"><a href="#分页性能优化" class="headerlink" title="分页性能优化"></a>分页性能优化</h2><p>es 的分页是较坑的，为啥呢？举个例子吧，假如你每页是 10 条数据，你现在要查询第 100 页，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上，如果你有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p><p>分布式的，你要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据吧？你<strong>必须</strong>得从每个 shard 都查 1000 条数据过来，然后根据你的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。你翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，非常坑爹。所以用 es 做分页的时候，你会发现越翻到后面，就越是慢。</p><p>我们之前也是遇到过这个问题，用 es 作分页，前几页就几十毫秒，翻到 10 页或者几十页的时候，基本上就要 5~10 秒才能查出来一页数据了。</p><p>有什么解决方案吗？</p><h3 id="不允许深度分页（默认深度分页性能很差）"><a href="#不允许深度分页（默认深度分页性能很差）" class="headerlink" title="不允许深度分页（默认深度分页性能很差）"></a>不允许深度分页（默认深度分页性能很差）</h3><p>跟产品经理说，你系统不允许翻那么深的页，默认翻的越深，性能就越差。</p><h3 id="类似于-app-里的推荐商品不断下拉出来一页一页的"><a href="#类似于-app-里的推荐商品不断下拉出来一页一页的" class="headerlink" title="类似于 app 里的推荐商品不断下拉出来一页一页的"></a>类似于 app 里的推荐商品不断下拉出来一页一页的</h3><p>类似于微博中，下拉刷微博，刷出来一页一页的，你可以用 <code>scroll api</code> ，关于如何使用，自行上网搜索。</p><p>scroll 会一次性给你生成<strong>所有数据的一个快照</strong>，然后每次滑动向后翻页就是通过<strong>游标</strong> <code>scroll_id</code> 移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。</p><p>但是，唯一的一点就是，这个适合于那种类似微博下拉翻页的，<strong>不能随意跳到任何一页的场景</strong>。也就是说，你不能先进入第 10 页，然后去第 120 页，然后又回到第 58 页，不能随意乱跳页。所以现在很多产品，都是不允许你随意翻页的，app，也有一些网站，做的就是你只能往下拉，一页一页的翻。</p><p>初始化时必须指定 <code>scroll</code> 参数，告诉 es 要保存此次搜索的上下文多长时间。你需要确保用户不会持续不断翻页翻几个小时，否则可能因为超时而失败。</p><p>除了用 <code>scroll api</code> ，你也可以用 <code>search_after</code> 来做， <code>search_after</code> 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生产集群的部署架构是什么？</title>
      <link href="/posts/61d83c03.html"/>
      <url>/posts/61d83c03.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES-生产集群的部署架构是什么？"><a href="#ES-生产集群的部署架构是什么？" class="headerlink" title="ES 生产集群的部署架构是什么？"></a>ES 生产集群的部署架构是什么？</h1><p>ES 生产集群的部署架构是什么？每个索引的数据量大概有多少？每个索引大概有多少个分片？</p><p>这个问题，包括后面的 redis 什么的，谈到 es、redis、mysql 分库分表等等技术，面试必问！就是你生产环境咋部署的？说白了，这个问题没啥技术含量，就是看你有没有在真正的生产环境里干过这事儿！</p><p>可能是没在生产环境中干过的，没实际去拿线上机器部署过 es 集群，也没实际玩儿过，也没往 es 集群里面导入过几千万甚至是几亿的数据量，可能你就不太清楚这里面的一些生产项目中的细节。</p><p>如果你是自己就玩儿过 demo，没碰过真实的 es 集群，那你可能此时会懵。别懵，你一定要云淡风轻的回答出来这个问题，表示你确实干过这事儿。</p><p>其实这个问题没啥，如果你确实干过 es，那你肯定了解你们生产 es 集群的实际情况，部署了几台机器？有多少个索引？每个索引有多大数据量？每个索引给了多少个分片？你肯定知道！</p><p>但是如果你确实没干过，也别虚，我给你说一个基本的版本，你到时候就简单说一下就好了。</p><ul><li>es 生产集群我们部署了 5 台机器，每台机器是 6 核 64G 的，集群总内存是 320G。</li><li>我们 es 集群的日增量数据大概是 2000 万条，每天日增量数据大概是 500MB，每月增量数据大概是 6 亿，15G。目前系统已经运行了几个月，现在 es 集群里数据总量大概是 100G 左右。</li><li>目前线上有 5 个索引（这个结合你们自己业务来，看看自己有哪些数据可以放 es 的），每个索引的数据量大概是 20G，所以这个数据量之内，我们每个索引分配的是 8 个 shard，比默认的 5 个 shard 多了 3 个 shard。</li></ul><p>大概就这么说一下就行了。</p>]]></content>
      
      
      <categories>
          
          <category> 全文检索 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx配置二级域名访问本机不同项目</title>
      <link href="/posts/d28ea01a.html"/>
      <url>/posts/d28ea01a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx配置二级域名访问本机不同项目"><a href="#Nginx配置二级域名访问本机不同项目" class="headerlink" title="Nginx配置二级域名访问本机不同项目"></a>Nginx配置二级域名访问本机不同项目</h1><h2 id="1-在域名管理控制台添加二级域名解析"><a href="#1-在域名管理控制台添加二级域名解析" class="headerlink" title="1.在域名管理控制台添加二级域名解析"></a>1.在域名管理控制台添加二级域名解析</h2><p>如在域名<a href="http://z11110.top/%E4%B8%8B%E6%B7%BB%E5%8A%A0%E4%B8%A4%E4%B8%AA%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%EF%BC%9A">http://z11110.top/下添加两个二级域名：</a></p><ul><li>7777.z11110.top</li><li>9999.z11110.top</li></ul><p>因域名解析需要时间，肯能刚解析完会有<code>延迟</code>，一般5分钟内解析完毕。</p><p><img src="https://i.loli.net/2020/12/24/OweMG2zpP9bLJhU.png" alt="image-20201224150428112"></p><h2 id="2-Nginx配置"><a href="#2-Nginx配置" class="headerlink" title="2.Nginx配置"></a>2.Nginx配置</h2><p>监听同一端口，一般为80端口，在http块中添加两个<code>server</code>块，分别在server中配置两个二级域名映射本地的端口</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> <span class="number">7777</span>.z11110.top; </span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://localhost:7777;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span> <span class="number">9999</span>.z11110.top;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">                <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://localhost:9999;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Nginx配置后，需要重启Nginx </p><h2 id="3-效果"><a href="#3-效果" class="headerlink" title="3.效果"></a>3.效果</h2><p>假设前提：</p><ul><li>访问<code>localhost:7777</code>服务端返回字符串“当前应用端口：7777”</li><li>访问<code>localhost:9999</code>服务端返回字符串“当前应用端口：9999”</li></ul><p>通过配置二级域名及Nginx配置，</p><ul><li>当客户端访问<code>7777.z11110.top</code>时，服务端返回字符串“当前应用端口：7777”</li><li>当客户端访问<code>9999.z11110.top</code>时，服务端返回字符串“当前应用端口：9999”</li></ul>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx负载均衡配置</title>
      <link href="/posts/5e0b5a44.html"/>
      <url>/posts/5e0b5a44.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h1><h2 id="1-Nginx负载均衡配置"><a href="#1-Nginx负载均衡配置" class="headerlink" title="1.Nginx负载均衡配置"></a>1.Nginx负载均衡配置</h2><h3 id="负载均衡概念：客户访问Nginx，由Nginx作为负载均衡服务器，根据预先设置好的调度规则（如：轮询、其他算法等）访问服务端，合理分配客户端请求。"><a href="#负载均衡概念：客户访问Nginx，由Nginx作为负载均衡服务器，根据预先设置好的调度规则（如：轮询、其他算法等）访问服务端，合理分配客户端请求。" class="headerlink" title="负载均衡概念：客户访问Nginx，由Nginx作为负载均衡服务器，根据预先设置好的调度规则（如：轮询、其他算法等）访问服务端，合理分配客户端请求。"></a>负载均衡概念：客户访问Nginx，由Nginx作为负载均衡服务器，根据预先设置好的调度规则（如：轮询、其他算法等）访问服务端，合理分配客户端请求。</h3><h3 id="在http块中配置upstream块，其中配置需要负载均衡访问的服务端"><a href="#在http块中配置upstream块，其中配置需要负载均衡访问的服务端" class="headerlink" title="在http块中配置upstream块，其中配置需要负载均衡访问的服务端"></a>在http块中配置upstream块，其中配置需要负载均衡访问的服务端</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">upstream</span> myserver&#123;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">9999</span>;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">7777</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Nginx配置后，需要重启Nginx</p><h2 id="2-负载均衡效果"><a href="#2-负载均衡效果" class="headerlink" title="2.负载均衡效果"></a>2.负载均衡效果</h2><p>假设前提：</p><ul><li>访问<code>localhost:7777</code>服务端返回字符串“当前应用端口：7777”</li><li>访问<code>localhost:9999</code>服务端返回字符串“当前应用端口：9999”</li></ul><p>通过Nginx负载均衡，根据算法路由到任一服务端进行请求响应，客户端访问<a href="http://z11110.top/%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%9A%8F%E6%9C%BA%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%E2%80%9C%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E7%AB%AF%E5%8F%A3%EF%BC%9A7777%E2%80%9D%E6%88%96%E2%80%9C%E5%BD%93%E5%89%8D%E5%BA%94%E7%94%A8%E7%AB%AF%E5%8F%A3%EF%BC%9A9999%E2%80%9D%EF%BC%8C%E7%94%B1%E6%AD%A4%E5%8D%B0%E8%AF%81%E5%B7%B2%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%82">http://z11110.top/，服务端随机返回字符串“当前应用端口：7777”或“当前应用端口：9999”，由此印证已实现负载均衡。</a></p><h2 id="3-负载均衡模式说明"><a href="#3-负载均衡模式说明" class="headerlink" title="3.负载均衡模式说明"></a>3.负载均衡模式说明</h2><h3 id="轮询（默认）：按时间逐一访问"><a href="#轮询（默认）：按时间逐一访问" class="headerlink" title="轮询（默认）：按时间逐一访问"></a>轮询（默认）：按时间逐一访问</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver&#123;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">9999</span>;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">7777</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="weight权重：根据权重分配请求"><a href="#weight权重：根据权重分配请求" class="headerlink" title="weight权重：根据权重分配请求"></a>weight权重：根据权重分配请求</h3><p>权重数值越大，被请求到的概率越大</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver&#123;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">9999</span> weight=<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">7777</span> weight=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fair：根据后端服务器响应时间分配请求，响应时间短的优先分配"><a href="#fair：根据后端服务器响应时间分配请求，响应时间短的优先分配" class="headerlink" title="fair：根据后端服务器响应时间分配请求，响应时间短的优先分配"></a>fair：根据后端服务器响应时间分配请求，响应时间短的优先分配</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver&#123;</span><br><span class="line">  <span class="attribute">fair</span></span><br><span class="line">        server localhost:<span class="number">9999</span>;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">7777</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="IP—Hash：对请求IP地址做Hash处理，将此请求分配到固定的后端服务器上"><a href="#IP—Hash：对请求IP地址做Hash处理，将此请求分配到固定的后端服务器上" class="headerlink" title="IP—Hash：对请求IP地址做Hash处理，将此请求分配到固定的后端服务器上"></a>IP—Hash：对请求IP地址做Hash处理，将此请求分配到固定的后端服务器上</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> myserver&#123;</span><br><span class="line">  <span class="attribute">ip_hash</span></span><br><span class="line">        server localhost:<span class="number">9999</span>;</span><br><span class="line">        <span class="attribute">server</span> localhost:<span class="number">7777</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie和Session</title>
      <link href="/posts/e919b2cc.html"/>
      <url>/posts/e919b2cc.html</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h1><h2 id="Http无状态"><a href="#Http无状态" class="headerlink" title="Http无状态"></a>Http无状态</h2><p>向服务器发起请求，得到服务器响应，服务器不会记录前后状态的改变。</p><p>这样就会导致，如果需要对前面的信息进行处理，需要重复发送请求，从而增加服务器负担、浪费资源。因此，需要维持前后状态改变，使得服务器能够识别客户端。</p><p>可以通过Cookie和Session实现这种Http连接维持状态。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie存在于客户端，当用户首次登录系统时，服务端生成Cookie，客户端储存；下次访问系统时，会携带相关Cookie发送请求到服务端，服务端通过Cookie鉴别用户信息</p><h3 id="浏览器查看Cookie属性"><a href="#浏览器查看Cookie属性" class="headerlink" title="浏览器查看Cookie属性"></a>浏览器查看Cookie属性</h3><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gkws9lttafj31sq0u0alv.jpg" alt="image-20201121143519068"  /><p><code>属性说明：</code></p><ol><li>name：名称，一旦创建不能修改</li><li>value：值，如果值为 Unicode 字符，需要为字符编码。如果值为二进制数据，则需要使用 BASE64 编码。</li><li>domain：能够访问该cookie的域名</li><li>path：cookie的使用路径，如果设置为 &#x2F;path&#x2F;，则只有路径为 &#x2F;path&#x2F; 的页面可以访问该 Cookie。如果设置为 &#x2F;，则本域名下的所有页面都可以访问该 Cookie</li><li>expires&#x2F;max-age：过期时间</li><li>httponly：若此属性为 true，则只有在 HTTP Headers 中会带有此 Cookie 的信息，而不能通过 document.cookie 来访问此 Cookie</li><li>security：是否仅被使用安全协议传输，安全协议有 HTTPS、SSL 等</li></ol><h3 id="运用场景：购物车、浏览记录、上次登录时间、记住密码等"><a href="#运用场景：购物车、浏览记录、上次登录时间、记住密码等" class="headerlink" title="运用场景：购物车、浏览记录、上次登录时间、记住密码等"></a>运用场景：购物车、浏览记录、上次登录时间、记住密码等</h3><h3 id="会话Cookie和持久Cookie：表面上，会话Cookie指储存在浏览器内存中，关闭浏览器则Cookie失效；持久Cookie指储存在计算机硬盘，能够持续使用。严格意义上，没有区分会话Cookie和持久Cookie，只是通过Cookie的expires和max-age控制过期时间"><a href="#会话Cookie和持久Cookie：表面上，会话Cookie指储存在浏览器内存中，关闭浏览器则Cookie失效；持久Cookie指储存在计算机硬盘，能够持续使用。严格意义上，没有区分会话Cookie和持久Cookie，只是通过Cookie的expires和max-age控制过期时间" class="headerlink" title="会话Cookie和持久Cookie：表面上，会话Cookie指储存在浏览器内存中，关闭浏览器则Cookie失效；持久Cookie指储存在计算机硬盘，能够持续使用。严格意义上，没有区分会话Cookie和持久Cookie，只是通过Cookie的expires和max age控制过期时间"></a>会话Cookie和持久Cookie：表面上，会话Cookie指储存在浏览器内存中，关闭浏览器则Cookie失效；持久Cookie指储存在计算机硬盘，能够持续使用。严格意义上，没有区分会话Cookie和持久Cookie，只是通过Cookie的expires和max age控制过期时间</h3><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session称之为会话（参照打电话的过程，从提起手机接听电话到挂断电话），存在于服务端，客户端发送的Cookie中储存着SESSIONID，通过SESSIONID，查找服务端对应的Session，实现用户信息认证</p><h3 id="Session维持：利用Cookie维持状态，当向服务器发送请求时，Cookie中储存对应用户的SESSIONID，服务器通过SESSIONID查找用户Session"><a href="#Session维持：利用Cookie维持状态，当向服务器发送请求时，Cookie中储存对应用户的SESSIONID，服务器通过SESSIONID查找用户Session" class="headerlink" title="Session维持：利用Cookie维持状态，当向服务器发送请求时，Cookie中储存对应用户的SESSIONID，服务器通过SESSIONID查找用户Session"></a>Session维持：利用Cookie维持状态，当向服务器发送请求时，Cookie中储存对应用户的SESSIONID，服务器通过SESSIONID查找用户Session</h3><h3 id="Session过期：在关闭浏览器时，并不会告知服务端需要销毁Session，一般会设置Session有效时间；大部分网站使用会话Cookie储存SESSIONID，Cookie过期后则服务端无法找到相应的Session"><a href="#Session过期：在关闭浏览器时，并不会告知服务端需要销毁Session，一般会设置Session有效时间；大部分网站使用会话Cookie储存SESSIONID，Cookie过期后则服务端无法找到相应的Session" class="headerlink" title="Session过期：在关闭浏览器时，并不会告知服务端需要销毁Session，一般会设置Session有效时间；大部分网站使用会话Cookie储存SESSIONID，Cookie过期后则服务端无法找到相应的Session"></a>Session过期：在关闭浏览器时，并不会告知服务端需要销毁Session，一般会设置Session有效时间；大部分网站使用会话Cookie储存SESSIONID，Cookie过期后则服务端无法找到相应的Session</h3>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程相关原理</title>
      <link href="/posts/942b1ba7.html"/>
      <url>/posts/942b1ba7.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程相关原理"><a href="#多线程相关原理" class="headerlink" title="多线程相关原理"></a>多线程相关原理</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>计算器同时运行着记事本和音乐播放器，这就是两个进程；而音乐播放器中，运行着歌词和音乐播放、视频播放等，这些就是进程中的每个线程。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是线程的集合，由一个或多个线程组成</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统运行调度的最小单位，是进程中最小运行单元</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行依赖于多核处理器，如果我们的计算机处理器只有一个核，那就不可能实现并行。指同一时刻，有多条指令在多个处理器上同时执行。</p><p>如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一时刻只有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。</p><p>比如一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。</p><p>系统处理器需要同时运行多个线程，如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。</p><h2 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a>多线程适用场景</h2><p>在处理一些比较耗时的任务时，为了提升效率，可以利用阻塞的时间进而执行其他任务，从而提升整体执行效率。</p><p>如：在查询数据库返回数据，网页等待过程中，利用多线程技术，执行其他线程任务，提升效率。</p><h2 id="IO密集型任务"><a href="#IO密集型任务" class="headerlink" title="IO密集型任务"></a>IO密集型任务</h2><p>比如网络爬虫就是一个非常典型的例子，爬虫在向服务器发起请求之后，有一段时间必须要等待服务器的响应返回，这种任务就属于 IO 密集型任务。对于这种任务，如果我们启用多线程，处理器就可以在某个线程等待的过程中去处理其他的任务，从而提高整体的爬取效率。</p><h2 id="计算密集型任务（CPU密集型任务）"><a href="#计算密集型任务（CPU密集型任务）" class="headerlink" title="计算密集型任务（CPU密集型任务）"></a>计算密集型任务（CPU密集型任务）</h2><p>顾名思义，就是任务的运行一直需要处理器的参与。此时如果我们开启了多线程，一个处理器从一个计算密集型任务切换到切换到另一个计算密集型任务上去，处理器依然不会停下来，始终会忙于计算，这样并不会节省总体的时间，因为需要处理的任务的计算总量是不变的。如果线程数目过多，反而还会在线程切换的过程中多耗费一些时间，整体效率会变低。</p><p>所以，如果任务不全是计算密集型任务，我们可以使用多线程来提高程序整体的执行效率。尤其对于网络爬虫这种 IO 密集型任务来说，使用多线程会大大提高程序整体的爬取效率。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现多进程</title>
      <link href="/posts/60740eb5.html"/>
      <url>/posts/60740eb5.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python实现多进程"><a href="#Python实现多进程" class="headerlink" title="Python实现多进程"></a>Python实现多进程</h1><p>Python 中的多线程是不能很好发挥多核优势的，如果想要发挥多核优势，最好还是使用多进程。</p><p>由于进程是线程的合集，并且一个进程可以包含多个线程，所以多进程的运行意味着有大于等于进程数量的线程运行着。</p><p>由于进程是系统进行调度和分配资源的独立单位，所以进程间的数据无法共享，如多进程之间共享一个全局变量，需要通过单独的机制来实现。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>计算器同时运行着记事本和音乐播放器，这就是两个进程；而音乐播放器中，运行着歌词和音乐播放、视频播放等，这些就是进程中的每个线程。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是线程的集合，由一个或多个线程组成</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统运行调度的最小单位，是进程中最小运行单元</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行依赖于多核处理器，如果我们的计算机处理器只有一个核，那就不可能实现并行。指同一时刻，有多条指令在多个处理器上同时执行。</p><p>如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一时刻只有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。</p><p>比如一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。</p><p>系统处理器需要同时运行多个线程，如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。</p><h2 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a>多线程适用场景</h2><p>在处理一些比较耗时的任务时，为了提升效率，可以利用阻塞的时间进而执行其他任务，从而提升整体执行效率。</p><p>如：在查询数据库返回数据，网页等待过程中，利用多线程技术，执行其他线程任务，提升效率。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python实现多线程</title>
      <link href="/posts/76920b79.html"/>
      <url>/posts/76920b79.html</url>
      
        <content type="html"><![CDATA[<h1 id="Python实现多线程"><a href="#Python实现多线程" class="headerlink" title="Python实现多线程"></a>Python实现多线程</h1><p>Python 中自带实现多线程的模块：threading</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>计算器同时运行着记事本和音乐播放器，这就是两个进程；而音乐播放器中，运行着歌词和音乐播放、视频播放等，这些就是进程中的每个线程。</p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是线程的集合，由一个或多个线程组成</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统运行调度的最小单位，是进程中最小运行单元</p><h2 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h2><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>并行依赖于多核处理器，如果我们的计算机处理器只有一个核，那就不可能实现并行。指同一时刻，有多条指令在多个处理器上同时执行。</p><p>如果系统处理器有多个核，当一个核在执行一个线程时，另一个核可以执行另一个线程，这样这两个线程就实现了并行执行，当然其他的线程也可能和另外的线程处在同一个核上执行，它们之间就是并发执行。具体的执行方式，就取决于操作系统的调度了。</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>同一时刻只有一条指令执行，但是多个线程的对应的指令被快速轮换地执行。</p><p>比如一个处理器，它先执行线程 A 的指令一段时间，再执行线程 B 的指令一段时间，再切回到线程 A 执行一段时间。</p><p>系统处理器需要同时运行多个线程，如果系统处理器只有一个核，那它只能通过并发的方式来运行这些线程。</p><h2 id="多线程适用场景"><a href="#多线程适用场景" class="headerlink" title="多线程适用场景"></a>多线程适用场景</h2><p>在处理一些比较耗时的任务时，为了提升效率，可以利用阻塞的时间进而执行其他任务，从而提升整体执行效率。</p><p>如：在查询数据库返回数据，网页等待过程中，利用多线程技术，执行其他线程任务，提升效率。</p>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爬虫相关概念</title>
      <link href="/posts/2d3be824.html"/>
      <url>/posts/2d3be824.html</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫相关概念"><a href="#爬虫相关概念" class="headerlink" title="爬虫相关概念"></a>爬虫相关概念</h1><h2 id="常见反爬措施"><a href="#常见反爬措施" class="headerlink" title="常见反爬措施"></a>常见反爬措施</h2><ol><li>JavaScript加密混淆</li><li>App加密混淆</li><li>检测IP地址</li><li>图形验证码</li></ol><h2 id="JavaScript逆向"><a href="#JavaScript逆向" class="headerlink" title="JavaScript逆向"></a>JavaScript逆向</h2><p>很多时候，为了保护前端数据的安全性，会对前端代码进行加密混淆处理，从而降低代码可读性和使得难以直接使用程序进行模拟</p><h2 id="App逆向"><a href="#App逆向" class="headerlink" title="App逆向"></a>App逆向</h2><p>App是重要的数据载体，为了保护数据安全，通常对数据接口添加加密参数，这些加密规则都写在App中，通过App逆向分析逻辑</p><h2 id="爬虫基本原理"><a href="#爬虫基本原理" class="headerlink" title="爬虫基本原理"></a>爬虫基本原理</h2><p><code>爬虫概述</code>：爬虫程序就是获取网页、App等信息载体上数据并进行储存的自动化程序</p><ol><li>获取网页源码：构造请求发送服务器，响应并获取网页源码，python提供获取网页源码的操作库，eg：urllib、requests等</li><li>提取信息：分析网页结构，提取数据，eg：正则表达式、css选择器、Beautiful Soup、pyquery、lxml等</li><li>储存数据：mysql、mongodb、redis、txt、json</li></ol>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot整合Redis</title>
      <link href="/posts/c67fec4a.html"/>
      <url>/posts/c67fec4a.html</url>
      
        <content type="html"><![CDATA[<h1 id="Springboot整合Redis"><a href="#Springboot整合Redis" class="headerlink" title="Springboot整合Redis"></a>Springboot整合Redis</h1><p>前提：安装Redis，略。</p><p>Springboot整合Redis有两种方式：</p><ol><li>Jedis：Redis官方推荐的面向Java操作Redis的客户端</li><li>RedisTemplate：SpringdataRedis对Jedis API高度封装</li></ol><p>这里主要说明通过Springboot整合Redis并通过RedisTemplate操作Redis，即第二种整合方式。</p><h2 id="1-IDEA新建工程，添加Redis依赖-pom-xml"><a href="#1-IDEA新建工程，添加Redis依赖-pom-xml" class="headerlink" title="1.IDEA新建工程，添加Redis依赖(pom.xml)"></a>1.IDEA新建工程，添加Redis依赖(pom.xml)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h2 id="2-配置连接参数（application-yml）"><a href="#2-配置连接参数（application-yml）" class="headerlink" title="2.配置连接参数（application.yml）"></a>2.配置连接参数（application.yml）</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">100</span></span><br><span class="line">        <span class="comment">#连接池中的最小空闲连接</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment">#连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">100000</span></span><br><span class="line">    <span class="comment"># 连接超时时间（毫秒）</span></span><br><span class="line">    <span class="attr">timeout:</span> <span class="number">5000</span></span><br><span class="line">    <span class="comment">#默认是索引为0的数据库</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="3-新建配置类，配置序列化方式"><a href="#3-新建配置类，配置序列化方式" class="headerlink" title="3.新建配置类，配置序列化方式"></a>3.新建配置类，配置序列化方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-新建RedisUtil，用于操作Redis"><a href="#4-新建RedisUtil，用于操作Redis" class="headerlink" title="4.新建RedisUtil，用于操作Redis"></a>4.新建RedisUtil，用于操作Redis</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定缓存失效时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">expire</span><span class="params">(String key, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.expire(key, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key 获取过期时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 时间(秒) 返回0代表为永久有效</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getExpire</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.getExpire(key, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断key是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasKey</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.hasKey(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 可以传一个值 或多个</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">del</span><span class="params">(String... key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">null</span> &amp;&amp; key.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.length == <span class="number">1</span>) &#123;</span><br><span class="line">                redisTemplate.delete(key[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                redisTemplate.delete(CollectionUtils.arrayToList(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================String=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存获取</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key == <span class="literal">null</span> ? <span class="literal">null</span> : redisTemplate.opsForValue().get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通缓存放入并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) time要大于0 如果time小于等于0 将设置无限期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">set</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set(key, value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递增</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">incr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递增因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta 要减少几(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">decr</span><span class="params">(String key, <span class="type">long</span> delta)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;递减因子必须大于0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().increment(key, -delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ================================Map=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashGet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">hget</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().get(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取hashKey对应的所有键值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 对应的多个键值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;Object, Object&gt; <span class="title function_">hmget</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().entries(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map 对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false 失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet 并设置时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map  对应多个键值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time 时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hmset</span><span class="params">(String key, Map&lt;String, Object&gt; map, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().putAll(key, map);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向一张hash表中放入数据,如果不存在将创建</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item  项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 成功 false失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hset</span><span class="params">(String key, String item, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForHash().put(key, item, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除hash表中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 可以使多个 不能为null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hdel</span><span class="params">(String key, Object... item)</span> &#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断hash表中是否有该项的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项 不能为null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hHasKey</span><span class="params">(String key, String item)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().hasKey(key, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递增 如果不存在,就会创建一个 并把新增后的值返回</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要增加几(大于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hincr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * hash递减</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key  键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> item 项</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> by   要减少记(小于0)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">hdecr</span><span class="params">(String key, String item, <span class="type">double</span> by)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForHash().increment(key, item, -by);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ============================set=============================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据key获取Set中的所有值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Object&gt; <span class="title function_">sGet</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据value从一个set中查询,是否存在</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true 存在 false不存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">sHasKey</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().isMember(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数据放入set缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSet</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将set数据放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time   时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sSetAndTime</span><span class="params">(String key, <span class="type">long</span> time, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().add(key, values);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取set缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">sGetSetSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除值为value的</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key    键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> values 值 可以是多个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">setRemove</span><span class="params">(String key, Object... values)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> redisTemplate.opsForSet().remove(key, values);</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ===============================list=================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的内容</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start 开始</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end   结束 0 到 -1代表所有值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Object&gt; <span class="title function_">lGet</span><span class="params">(String key, <span class="type">long</span> start, <span class="type">long</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().range(key, start, end);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取list缓存的长度</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lGetListSize</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().size(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过索引 获取list中的值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">lGetIndex</span><span class="params">(String key, <span class="type">long</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForList().index(key, index);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, Object value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPush(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list放入缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time  时间(秒)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lSet</span><span class="params">(String key, List&lt;Object&gt; value, <span class="type">long</span> time)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().rightPushAll(key, value);</span><br><span class="line">            <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                expire(key, time);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据索引修改list中的某条数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lUpdateIndex</span><span class="params">(String key, <span class="type">long</span> index, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            redisTemplate.opsForList().set(key, index, value);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除N个值为value</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key   键</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 移除多少个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 移除的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lRemove</span><span class="params">(String key, <span class="type">long</span> count, Object value)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Long</span> <span class="variable">remove</span> <span class="operator">=</span> redisTemplate.opsForList().remove(key, count, value);</span><br><span class="line">            <span class="keyword">return</span> remove;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis序列化LocalDateTime报错</title>
      <link href="/posts/d81abf34.html"/>
      <url>/posts/d81abf34.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis序列化LocalDateTime报错"><a href="#Redis序列化LocalDateTime报错" class="headerlink" title="Redis序列化LocalDateTime报错"></a>Redis序列化LocalDateTime报错</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>实体类日期字段使用LocalDateTime，在Redis序列化时报错，会往Redis中写入如下数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;createTime&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;date&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;year&quot;</span><span class="punctuation">:</span> <span class="number">2019</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;month&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MAY&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;day&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;prolepticMonth&quot;</span><span class="punctuation">:</span> <span class="number">24232</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;era&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="string">&quot;java.time.chrono.IsoEra&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="string">&quot;CE&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dayOfYear&quot;</span><span class="punctuation">:</span> <span class="number">135</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dayOfWeek&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WEDNESDAY&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;leapYear&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;dayOfMonth&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;monthValue&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;chronology&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISO&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;calendarType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iso8601&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;time&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;hour&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;minute&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;second&quot;</span><span class="punctuation">:</span> <span class="number">43</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;nano&quot;</span><span class="punctuation">:</span> <span class="number">758000000</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dayOfYear&quot;</span><span class="punctuation">:</span> <span class="number">135</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dayOfWeek&quot;</span><span class="punctuation">:</span> <span class="string">&quot;WEDNESDAY&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;month&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MAY&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dayOfMonth&quot;</span><span class="punctuation">:</span> <span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;year&quot;</span><span class="punctuation">:</span> <span class="number">2019</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;monthValue&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;hour&quot;</span><span class="punctuation">:</span> <span class="number">11</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;minute&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;second&quot;</span><span class="punctuation">:</span> <span class="number">43</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;nano&quot;</span><span class="punctuation">:</span> <span class="number">758000000</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;chronology&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;java.time.chrono.IsoChronology&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISO&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;calendarType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;iso8601&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="方案一：实体类日期字段添加注解"><a href="#方案一：实体类日期字段添加注解" class="headerlink" title="方案一：实体类日期字段添加注解"></a>方案一：实体类日期字段添加注解</h2><p>每个LocalDateTime类型字段都需要添加，不建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonDeserialize(using = LocalDateTimeDeserializer.class)</span></span><br><span class="line"><span class="meta">@JsonSerialize(using = LocalDateTimeSerializer.class)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime birthday;</span><br></pre></td></tr></table></figure><h2 id="方案二：设置Redis对日期序列化处理"><a href="#方案二：设置Redis对日期序列化处理" class="headerlink" title="方案二：设置Redis对日期序列化处理"></a>方案二：设置Redis对日期序列化处理</h2><h3 id="添加配置："><a href="#添加配置：" class="headerlink" title="添加配置："></a>添加配置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日期序列化处理</span></span><br><span class="line">om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">om.registerModule(<span class="keyword">new</span> <span class="title class_">Jdk8Module</span>())</span><br><span class="line">  .registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>())</span><br><span class="line">  .registerModule(<span class="keyword">new</span> <span class="title class_">ParameterNamesModule</span>());</span><br></pre></td></tr></table></figure><h3 id="完整配置："><a href="#完整配置：" class="headerlink" title="完整配置："></a>完整配置：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> &#123;</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 配置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span></span><br><span class="line">        <span class="type">Jackson2JsonRedisSerializer</span> <span class="variable">jacksonSeial</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jackson2JsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">ObjectMapper</span> <span class="variable">om</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">        <span class="comment">// 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public</span></span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        <span class="comment">// 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常</span></span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jacksonSeial.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 值采用json序列化</span></span><br><span class="line">        template.setValueSerializer(jacksonSeial);</span><br><span class="line">        <span class="comment">//使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置hash key 和value序列化模式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(jacksonSeial);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 日期序列化处理</span></span><br><span class="line">        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">        om.registerModule(<span class="keyword">new</span> <span class="title class_">Jdk8Module</span>())</span><br><span class="line">                .registerModule(<span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>())</span><br><span class="line">                .registerModule(<span class="keyword">new</span> <span class="title class_">ParameterNamesModule</span>());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LocalDateTime日期转换错误</title>
      <link href="/posts/8896d0a5.html"/>
      <url>/posts/8896d0a5.html</url>
      
        <content type="html"><![CDATA[<h1 id="LocalDateTime日期转换错误-JSON-parse-error-Cannot-deserialize-value-of-type-java-time-LocalDateTime"><a href="#LocalDateTime日期转换错误-JSON-parse-error-Cannot-deserialize-value-of-type-java-time-LocalDateTime" class="headerlink" title="LocalDateTime日期转换错误:JSON parse error: Cannot deserialize value of type java.time.LocalDateTime"></a>LocalDateTime日期转换错误:JSON parse error: Cannot deserialize value of type <code>java.time.LocalDateTime</code></h1><h2 id="背景：实体类日期字段使用LocalDateTime，使用Postman测试时报错"><a href="#背景：实体类日期字段使用LocalDateTime，使用Postman测试时报错" class="headerlink" title="背景：实体类日期字段使用LocalDateTime，使用Postman测试时报错"></a>背景：实体类日期字段使用LocalDateTime，使用Postman测试时报错</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Resolved [org.springframework.http.converter.HttpMessageNotReadableException: </span><br><span class="line">JSON parse error: Cannot deserialize value of type `java.time.LocalDateTime` from String </span><br><span class="line"><span class="string">&quot;2019-09-11 07:23:59&quot;</span>: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text <span class="string">&#x27;2019-09-11 07:23:59&#x27;</span></span><br><span class="line"> could not be parsed at index <span class="number">10</span>; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: </span><br><span class="line"> Cannot deserialize value of type `java.time.LocalDateTime` from String <span class="string">&quot;2019-09-11 07:23:59&quot;</span>: </span><br><span class="line"> Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) </span><br><span class="line"> Text <span class="string">&#x27;2019-09-11 07:23:59&#x27;</span> could not be parsed at index <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="方案一：实体类字段格式化日期"><a href="#方案一：实体类字段格式化日期" class="headerlink" title="方案一：实体类字段格式化日期"></a>方案一：实体类字段格式化日期</h2><p>每个实体类的日期字段都要格式化一次，不建议使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime birthday;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonFormat(locale = &quot;zh&quot;, timezone = &quot;GMT+8&quot;, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime modify;</span><br></pre></td></tr></table></figure><h2 id="方案二：增加日期转换配置类"><a href="#方案二：增加日期转换配置类" class="headerlink" title="方案二：增加日期转换配置类"></a>方案二：增加日期转换配置类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateTimeSerializerConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATE_TIME_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DATE_PATTERN</span> <span class="operator">=</span> <span class="string">&quot;yyyy-MM-dd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string转localdate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, LocalDate&gt; <span class="title function_">localDateConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, LocalDate&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalDate <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (source.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalDate.parse(source);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalDate.parse(source, DateTimeFormatter.ofPattern(DATE_PATTERN));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string转localdatetime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;String, LocalDateTime&gt; <span class="title function_">localDateTimeConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Converter</span>&lt;String, LocalDateTime&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> LocalDateTime <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (source.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 先尝试ISO格式: 2019-07-15T16:00:00</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalDateTime.parse(source);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> LocalDateTime.parse(source, DateTimeFormatter.ofPattern(DATE_TIME_PATTERN));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 统一配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Jackson2ObjectMapperBuilderCustomizer <span class="title function_">jsonCustomizer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JavaTimeModule</span> <span class="variable">module</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JavaTimeModule</span>();</span><br><span class="line">        <span class="type">LocalDateTimeDeserializer</span> <span class="variable">localDateTimeDeserializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LocalDateTimeDeserializer</span>(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>));</span><br><span class="line">        <span class="keyword">module</span>.addDeserializer(LocalDateTime.class, localDateTimeDeserializer);</span><br><span class="line">        <span class="keyword">return</span> builder -&gt; &#123;</span><br><span class="line">            builder.simpleDateFormat(DATE_TIME_PATTERN);</span><br><span class="line">            builder.serializers(<span class="keyword">new</span> <span class="title class_">LocalDateSerializer</span>(DateTimeFormatter.ofPattern(DATE_PATTERN)));</span><br><span class="line">            builder.serializers(<span class="keyword">new</span> <span class="title class_">LocalDateTimeSerializer</span>(DateTimeFormatter.ofPattern(DATE_TIME_PATTERN)));</span><br><span class="line">            builder.modules(<span class="keyword">module</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么使用消息队列？</title>
      <link href="/posts/43cca95f.html"/>
      <url>/posts/43cca95f.html</url>
      
        <content type="html"><![CDATA[<h1 id="为什么使用消息队列？"><a href="#为什么使用消息队列？" class="headerlink" title="为什么使用消息队列？"></a>为什么使用消息队列？</h1><p>Question：</p><ol><li>为什么使用消息队列？业务场景</li><li>有什么好处&amp;坏处</li><li>消息队列对比（为什么选其中一种）</li></ol><h2 id="消息队列的使用场景"><a href="#消息队列的使用场景" class="headerlink" title="消息队列的使用场景"></a>消息队列的使用场景</h2><p>Answer：解耦、异步、异步削峰</p><h3 id="解耦："><a href="#解耦：" class="headerlink" title="解耦："></a>解耦：</h3><p>有以下场景，A 系统通过调用接口，给BCD系统推送数据，如果 E 系统也要这个数据呢？那如果 C 系统现在不需要了呢？</p><p>如果A系统向其他系统推送数据时，其他系统出现问题宕机了呢？要不要重发？怎么重发？</p><p>消息如何做持久化处理？</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-1.png" alt="mq-1" style="zoom: 67%;" /><h4 id="通过使用MQ进行系统之间的解耦，A系统作为生产者发送消息到MQ，其他系统作为消费者通过订阅MQ获取A系统发送的消息。新增的系统订阅到MQ中，不需要接收消息的系统通过取消订阅MQ即可。"><a href="#通过使用MQ进行系统之间的解耦，A系统作为生产者发送消息到MQ，其他系统作为消费者通过订阅MQ获取A系统发送的消息。新增的系统订阅到MQ中，不需要接收消息的系统通过取消订阅MQ即可。" class="headerlink" title="通过使用MQ进行系统之间的解耦，A系统作为生产者发送消息到MQ，其他系统作为消费者通过订阅MQ获取A系统发送的消息。新增的系统订阅到MQ中，不需要接收消息的系统通过取消订阅MQ即可。"></a>通过使用MQ进行系统之间的解耦，A系统作为<code>生产者</code>发送消息到MQ，其他系统作为<code>消费者</code>通过订阅MQ获取A系统发送的消息。新增的系统<code>订阅</code>到MQ中，不需要接收消息的系统通过<code>取消订阅</code>MQ即可。</h4><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-2.png" alt="mq-2" style="zoom:67%;" /><hr><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、450ms、200ms。最终请求总延时是 3 + 300 + 450 + 200 &#x3D; 953ms，接近 1s，用户感觉搞个什么东西，慢死了慢死了。用户通过浏览器发起请求，等待个 1s，这几乎是不可接受的。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-3.png" alt="mq-3" style="zoom:67%;" /><h4 id="如果使用-MQ，那么-A-系统连续发送-3-条消息到-MQ-队列中，假如耗时-5ms，A-系统从接受一个请求到返回响应给用户，总时长是-3-5-8ms，对于用户而言，其实感觉上就是点个按钮，8ms-以后就直接返回了。"><a href="#如果使用-MQ，那么-A-系统连续发送-3-条消息到-MQ-队列中，假如耗时-5ms，A-系统从接受一个请求到返回响应给用户，总时长是-3-5-8ms，对于用户而言，其实感觉上就是点个按钮，8ms-以后就直接返回了。" class="headerlink" title="如果使用 MQ，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了。"></a>如果<strong>使用 MQ</strong>，那么 A 系统连续发送 3 条消息到 MQ 队列中，假如耗时 5ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 5 &#x3D; 8ms，对于用户而言，其实感觉上就是点个按钮，8ms 以后就直接返回了。</h4><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-4.png" alt="mq-4" style="zoom:67%;" /><hr><h3 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h3><p>场景：每天 0:00 到 12:00，A 系统风平浪静，每秒并发请求数量就 50 个。结果每次一到 12:00 ~ 13:00 ，每秒并发请求数量突然会暴增到 5k+ 条。但是系统是直接基于 MySQL 的，大量的请求涌入 MySQL，每秒钟对 MySQL 执行约 5k 条 SQL。</p><p>一般的 MySQL，扛到每秒 2k 个请求就差不多了，如果每秒请求到 5k 的话，可能就直接把 MySQL 给打死了，导致系统崩溃，用户也就没法再使用系统了。</p><p>但是高峰期一过，到了下午的时候，就成了低峰期，可能也就 1w 的用户同时在网站上操作，每秒中的请求数量可能也就 50 个请求，对整个系统几乎没有任何的压力。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-5.png" alt="mq-5" style="zoom:67%;" /><h4 id="如果使用-MQ，每秒-5k-个请求写入-MQ，A-系统每秒钟最多处理-2k-个请求，因为-MySQL-每秒钟最多处理-2k-个。A-系统从-MQ-中慢慢拉取请求，每秒钟就拉取-2k-个请求，不要超过自己每秒能处理的最大请求数量就-ok，这样下来，哪怕是高峰期的时候，A-系统也绝对不会挂掉。而-MQ-每秒钟-5k-个请求进来，就-2k-个请求出去，结果就导致在中午高峰期（1-个小时），可能有几十万甚至几百万的请求积压在-MQ-中。"><a href="#如果使用-MQ，每秒-5k-个请求写入-MQ，A-系统每秒钟最多处理-2k-个请求，因为-MySQL-每秒钟最多处理-2k-个。A-系统从-MQ-中慢慢拉取请求，每秒钟就拉取-2k-个请求，不要超过自己每秒能处理的最大请求数量就-ok，这样下来，哪怕是高峰期的时候，A-系统也绝对不会挂掉。而-MQ-每秒钟-5k-个请求进来，就-2k-个请求出去，结果就导致在中午高峰期（1-个小时），可能有几十万甚至几百万的请求积压在-MQ-中。" class="headerlink" title="如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。"></a>如果使用 MQ，每秒 5k 个请求写入 MQ，A 系统每秒钟最多处理 2k 个请求，因为 MySQL 每秒钟最多处理 2k 个。A 系统从 MQ 中慢慢拉取请求，每秒钟就拉取 2k 个请求，不要超过自己每秒能处理的最大请求数量就 ok，这样下来，哪怕是高峰期的时候，A 系统也绝对不会挂掉。而 MQ 每秒钟 5k 个请求进来，就 2k 个请求出去，结果就导致在中午高峰期（1 个小时），可能有几十万甚至几百万的请求积压在 MQ 中。</h4><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-6.png" alt="mq-6" style="zoom:67%;" /><h4 id="这个短暂的高峰期积压是-ok-的，因为高峰期过了之后，每秒钟就-50-个请求进-MQ，但是-A-系统依然会按照每秒-2k-个请求的速度在处理。所以说，只要高峰期一过，A-系统就会快速将积压的消息给解决掉。"><a href="#这个短暂的高峰期积压是-ok-的，因为高峰期过了之后，每秒钟就-50-个请求进-MQ，但是-A-系统依然会按照每秒-2k-个请求的速度在处理。所以说，只要高峰期一过，A-系统就会快速将积压的消息给解决掉。" class="headerlink" title="这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。"></a>这个短暂的高峰期积压是 ok 的，因为高峰期过了之后，每秒钟就 50 个请求进 MQ，但是 A 系统依然会按照每秒 2k 个请求的速度在处理。所以说，只要高峰期一过，A 系统就会快速将积压的消息给解决掉。</h4><hr><h2 id="消息队列优缺点"><a href="#消息队列优缺点" class="headerlink" title="消息队列优缺点"></a>消息队列优缺点</h2><p>优点就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><p>缺点有以下几个：</p><ul><li>系统可用性降低</li></ul><p>系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？如何保证消息队列的高可用，可以<a href="https://doocs.gitee.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues">点击这里查看</a>。</p><ul><li>系统复杂度提高</li></ul><p>硬生生加个 MQ 进来，你怎么<a href="https://doocs.gitee.io/advanced-java/#/docs/high-concurrency/how-to-ensure-that-messages-are-not-repeatedly-consumed">保证消息没有重复消费</a>？怎么<a href="https://doocs.gitee.io/advanced-java/#/docs/high-concurrency/how-to-ensure-the-reliable-transmission-of-messages">处理消息丢失的情况</a>？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已。</p><ul><li>一致性问题</li></ul><p>A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。</p><p>所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，做好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了 10 倍。但是关键时刻，用，还是得用的。</p><h3 id="市面上MQ对比"><a href="#市面上MQ对比" class="headerlink" title="市面上MQ对比"></a>市面上MQ对比</h3><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>综上，各种对比之后，有如下建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息队列的高可用？</title>
      <link href="/posts/bf58abd7.html"/>
      <url>/posts/bf58abd7.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何保证消息队列的高可用？"><a href="#如何保证消息队列的高可用？" class="headerlink" title="如何保证消息队列的高可用？"></a>如何保证消息队列的高可用？</h1><h2 id="RabbitMQ的高可用"><a href="#RabbitMQ的高可用" class="headerlink" title="RabbitMQ的高可用"></a>RabbitMQ的高可用</h2><p>RabbitMQ 是比较有代表性的，因为是<strong>基于主从</strong>（非分布式）做高可用性的。</p><p>RabbitMQ 有三种模式：<code>单机模式、普通集群模式、镜像集群模式</code>。</p><h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>本地测试，生产环境不能使用单机模式</p><h3 id="普通集群模式"><a href="#普通集群模式" class="headerlink" title="普通集群模式"></a>普通集群模式</h3><p>普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。但是通过程序创建的Queue只存在于其中一台实例上，其他实例可以同步Queue的元数据（可以理解为配置信息，通过元数据可以找到Queue实例）。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-7.png" alt="mq-7" style="zoom:67%;" /><p>这种方式并没有做到真正的分布式，当消费者访问到非Queue实例时，当前实例需要同步Queue实例元数据，再拉取数据。如果Queue实例宕机，会导致其他实例无法拉取，如果开启了消息持久化，消息不一定会丢失，但需要恢复实例后才正常使用。这种方案只要用户提高吞吐量，让集群中多个节点服务某个Queue实例的读写。</p><h3 id="镜像集群模式"><a href="#镜像集群模式" class="headerlink" title="镜像集群模式"></a>镜像集群模式</h3><p>这种方式相对与普通<code>集群</code>模式，每个实例都包含完整Queue镜像</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-8.png" alt="mq-8" style="zoom:67%;" /><p>好处在于不用担心某一个实例宕机，缺点是资源开销大，没有办法线性拓展</p><hr><h2 id="Kafka的高可用"><a href="#Kafka的高可用" class="headerlink" title="Kafka的高可用"></a>Kafka的高可用</h2><p>Kafka 一个最基本的架构认识：由多个 broker 组成，每个 broker 是一个节点；你创建一个 topic，这个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上，每个 partition 就放一部分数据。</p><p>这就是<strong>天然的<code>分布式</code>消息队列</strong>，就是说一个 topic 的数据，是**分散放在多个机器上的，<code>每个机器就放一部分数据</code>**。</p><p>实际上 <code>RabbitMQ 之类的，并不是分布式消息队列</code>，它就是传统的消息队列，只不过提供了一些集群、HA(High Availability, 高可用性) 的机制而已，因为无论怎么玩儿，RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是<code>每个节点都放这个 queue 的完整数据</code>。</p><p>Kafka 0.8 以前，是没有 HA 机制的，就是任何一个 broker 宕机了，那个 broker 上的 partition 就废了，没法写也没法读，没有什么高可用性可言。</p><p>比如说，我们假设创建了一个 topic，指定其 partition 数量是 3 个，分别在三台机器上。但是，如果第二台机器宕机了，会导致这个 topic 的 1&#x2F;3 的数据就丢了，因此这个是做不到高可用的。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/kafka-before.png" alt="kafka-before" style="zoom:67%;" /><p>Kafka 0.8 以后，提供了 HA 机制，就是 replica（复制品） 副本机制。每个 partition 的数据都会同步到其它机器上，形成自己的多个 replica 副本。所有 replica 会选举一个 leader 出来，那么生产和消费都跟这个 leader 打交道，然后其他 replica 就是 follower。写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上的数据即可。只能读写 leader？很简单，<strong>要是你可以随意读写每个 follower，那么就要 care 数据一致性的问题</strong>，系统复杂度太高，很容易出问题。Kafka 会均匀地将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p>这么搞，就有所谓的<strong>高可用性</strong>了，因为如果某个 broker 宕机了，没事儿，那个 broker 上面的 partition 在其他机器上都有副本的。如果这个宕机的 broker 上面有某个 partition 的 leader，那么此时会从 follower 中<strong>重新选举</strong>一个新的 leader 出来，大家继续读写那个新的 leader 即可。这就有所谓的高可用性了。</p><p><strong>写数据</strong>的时候，生产者就写 leader，然后 leader 将数据落地写本地磁盘，接着其他 follower 自己主动从 leader 来 pull 数据。一旦所有 follower 同步好数据了，就会发送 ack 给 leader，leader 收到所有 follower 的 ack 之后，就会返回写成功的消息给生产者。（当然，这只是其中一种模式，还可以适当调整这个行为）</p><p><strong>消费</strong>的时候，只会从 leader 去读，但是只有当一个消息已经被所有 follower 都同步成功返回 ack 的时候，这个消息才会被消费者读到。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/kafka-after.png" alt="kafka-after" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息不被重复消费？（幂等性）</title>
      <link href="/posts/1e597e71.html"/>
      <url>/posts/1e597e71.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何保证消息不被重复消费？（幂等性）"><a href="#如何保证消息不被重复消费？（幂等性）" class="headerlink" title="如何保证消息不被重复消费？（幂等性）"></a>如何保证消息不被重复消费？（幂等性）</h1><h2 id="可能会有哪些重复消费的问题？"><a href="#可能会有哪些重复消费的问题？" class="headerlink" title="可能会有哪些重复消费的问题？"></a><strong>可能会有哪些重复消费的问题？</strong></h2><p>RabbitMQ、RocketMQ、Kafka，都有可能会出现消息重复消费的问题，正常。因为这问题通常不是 MQ 自己保证的，是由我们开发来保证的。</p><p>Kafka 实际上有个 offset 的概念，就是每个消息写进去，都有一个 offset，代表消息的序号，然后 consumer 消费了数据之后，<strong>每隔一段时间</strong>（定时定期），会把自己消费过的消息的 offset 提交一下，表示“我已经消费过了，下次我要是重启啥的，你就让我继续从上次消费到的 offset 来继续消费吧”。</p><p>但是凡事总有意外，比如我们之前生产经常遇到的，就是你有时候重启系统，看你怎么重启了，如果碰到点着急的，直接 kill 进程了，再重启。这会导致 consumer 有些消息处理了，但是没来得及提交 offset，尴尬了。重启之后，少数消息会再次消费一次。</p><p>举个栗子。</p><p>有这么个场景。数据 1&#x2F;2&#x2F;3 依次进入 kafka，kafka 会给这三条数据每条分配一个 offset，代表这条数据的序号，我们就假设分配的 offset 依次是 152&#x2F;153&#x2F;154。消费者从 kafka 去消费的时候，也是按照这个顺序去消费。假如当消费者消费了 <code>offset=153</code> 的这条数据，刚准备去提交 offset 到 zookeeper，此时消费者进程被重启了。那么此时消费过的数据 1&#x2F;2 的 offset 并没有提交，kafka 也就不知道你已经消费了 <code>offset=153</code> 这条数据。那么重启之后，消费者会找 kafka 说，嘿，哥儿们，你给我接着把上次我消费到的那个地方后面的数据继续给我传递过来。由于之前的 offset 没有提交成功，那么数据 1&#x2F;2 会再次传过来，如果此时消费者没有去重的话，那么就会导致重复消费。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-10.png" alt="mq-10" style="zoom:67%;" /><p>果消费者干的事儿是拿一条数据就往数据库里写一条，会导致说，你可能就把数据 1&#x2F;2 在数据库里插入了 2 次，那么数据就错啦。</p><p>其实重复消费不可怕，可怕的是你没考虑到重复消费之后，<strong>怎么保证幂等性</strong>。</p><p>举个例子吧。假设你有个系统，消费一条消息就往数据库里插入一条数据，要是你一个消息重复两次，你不就插入了两条，这数据不就错了？但是你要是消费到第二次的时候，自己判断一下是否已经消费过了，若是就直接扔了，这样不就保留了一条数据，从而保证了数据的正确性。</p><p>一条数据重复出现两次，数据库里就只有一条数据，这就保证了系统的幂等性。</p><p>幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，<strong>不能出错</strong>。</p><h2 id="如何保证消息队列消费的幂等性？"><a href="#如何保证消息队列消费的幂等性？" class="headerlink" title="如何保证消息队列消费的幂等性？"></a>如何保证消息队列消费的幂等性？</h2><p>其实还是得结合业务来思考，我这里给几个思路：</p><ul><li>比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li><li>比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li><li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li><li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li></ul><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/mq-11.png" alt="mq-11" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息的可靠性传输？</title>
      <link href="/posts/bfa1c04f.html"/>
      <url>/posts/bfa1c04f.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何保证消息的可靠性传输？"><a href="#如何保证消息的可靠性传输？" class="headerlink" title="如何保证消息的可靠性传输？"></a>如何保证消息的可靠性传输？</h1><h2 id="如何处理消息丢失？"><a href="#如何处理消息丢失？" class="headerlink" title="如何处理消息丢失？"></a>如何处理消息丢失？</h2><p>数据的丢失问题，可能出现在生产者、MQ、消费者中，咱们从 RabbitMQ 和 Kafka 分别来分析一下。</p><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/rabbitmq-message-lose.png" alt="rabbitmq-message-lose" style="zoom:67%;" /><h4 id="生产者弄丢了数据"><a href="#生产者弄丢了数据" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h4><p>&#x3D;&#x3D;第一种方式&#x3D;&#x3D;可以使用RabbitMQ提供的事务功能：在生产者<strong>发送数据之前</strong>开启RabbitMQ事务<code>channel.txSelect</code>，然后发送消息，如果消息没有被RabbitMQ接收到，那么生产者会收到异常报错，此时可以回滚事务<code>channel.txRollback</code>，然后重试发送消息，如果收到消息，就可以提交事务<code>channel.txCommit</code>。</p><p>但是这种方式太耗性能，基本上吞吐量会降低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启事务</span></span><br><span class="line">channel.txSelect</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里发送消息</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    channel.txRollback</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里再次重发这条消息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交事务</span></span><br><span class="line">channel.txCommit</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;第二种方式&#x3D;&#x3D;可以开启<code>confirm</code>模式，在生产者那里设置开启confirm模式后，每次写的消息会分配一个唯一的id，然后如果成功写入RabbitMQ中，会返回一个<code>ack</code>消息；如果RabbitMQ 没有处理这个消息，会回调你的<code>nack</code>接口，说明这个消息接收失败，这时可以重试发送消息，而且可以结合这个机制在内存里维护每个消息id的状态，如果超过一定时间还没接收到这个消息的回调，可以重发。</p><p>事务机制和 <code>confirm</code> 机制最大的不同在于，<strong>事务机制是同步的</strong>，你提交一个事务之后会<strong>阻塞</strong>在那儿，但是 <code>confirm</code> 机制是<strong>异步</strong>的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。</p><p>所以一般在生产者这块<strong>避免数据丢失</strong>，都是用 <code>confirm</code> 机制的。</p><hr><h4 id="RabbitMQ弄丢了数据"><a href="#RabbitMQ弄丢了数据" class="headerlink" title="RabbitMQ弄丢了数据"></a>RabbitMQ弄丢了数据</h4><p>必须**<code>开启 RabbitMQ 的持久化</code><strong>，消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 挂了，</strong>恢复之后会自动读取之前存储的数据<strong>，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，</strong>可能导致少量数据丢失**，但是这个概率较小。</p><p>设置持久化有<strong>两个步骤</strong>：</p><ul><li>创建 queue 的时候将其设置为持久化</li></ul><p>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。</p><ul><li>第二个是发送消息的时候将消息的 <code>deliveryMode</code> 设置为 2</li></ul><p><code>必须要同时设置这两个持久化才行</code>，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。</p><p>注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p><p>所以，持久化可以跟生产者那边的 <code>confirm</code> 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 <code>ack</code> 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 <code>ack</code> ，你也是可以自己重发的。</p><hr><h4 id="消费者弄丢了数据"><a href="#消费者弄丢了数据" class="headerlink" title="消费者弄丢了数据"></a>消费者弄丢了数据</h4><p>RabbitMQ 如果丢失了数据，主要是因为你消费的时候，<strong>刚消费到，还没处理，结果进程挂了</strong>，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。</p><p>这个时候得用 RabbitMQ 提供的 <code>ack</code> 机制，简单来说，就是你必须<code>关闭 RabbitMQ 的自动</code> <code>ack</code> ，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 <code>ack</code> 一把。这样的话，如果你还没处理完，不就没有 <code>ack</code> 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/rabbitmq-message-lose-solution.png" alt="rabbitmq-message-lose-solution" style="zoom:67%;" /><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><h4 id="消费者弄丢了数据-1"><a href="#消费者弄丢了数据-1" class="headerlink" title="消费者弄丢了数据"></a>消费者弄丢了数据</h4><p>唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边<strong>自动提交了 offset</strong>，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。</p><p>这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要<strong>关闭自动提交</strong> offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是<strong>可能会有重复消费</strong>，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。</p><p>生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。</p><h4 id="kafka弄丢了数据"><a href="#kafka弄丢了数据" class="headerlink" title="kafka弄丢了数据"></a>kafka弄丢了数据</h4><p>这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。</p><p>生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。</p><p>所以此时一般是要求起码设置如下 4 个参数：</p><ul><li>给 topic 设置 <code>replication.factor</code> 参数：这个值必须大于 1，要求每个 partition 必须有至少 2 个副本。</li><li>在 Kafka 服务端设置 <code>min.insync.replicas</code> 参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。</li><li>在 producer 端设置 <code>acks=all</code> ：这个是要求每条数据，必须是<strong>写入所有 replica 之后，才能认为是写成功了</strong>。</li><li>在 producer 端设置 <code>retries=MAX</code> （很大很大很大的一个值，无限次重试的意思）：这个是<strong>要求一旦写入失败，就无限重试</strong>，卡在这里了。</li></ul><p>我们生产环境就是按照上述要求配置的，这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。</p><h4 id="生产者弄丢了数据-1"><a href="#生产者弄丢了数据-1" class="headerlink" title="生产者弄丢了数据"></a>生产者弄丢了数据</h4><p>如果按照上述的思路设置了 <code>acks=all</code> ，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何解决消息队列的延时以及过期失效问题？</title>
      <link href="/posts/14abf26.html"/>
      <url>/posts/14abf26.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何解决消息队列的延时以及过期失效问题？"><a href="#如何解决消息队列的延时以及过期失效问题？" class="headerlink" title="如何解决消息队列的延时以及过期失效问题？"></a>如何解决消息队列的延时以及过期失效问题？</h1><p>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</p><p>你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？</p><p>所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。</p><h2 id="大量消息在-mq-里积压了几个小时了还没解决"><a href="#大量消息在-mq-里积压了几个小时了还没解决" class="headerlink" title="大量消息在 mq 里积压了几个小时了还没解决"></a>大量消息在 mq 里积压了几个小时了还没解决</h2><p>几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。</p><p>一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。</p><p>一般这个时候，只能<code>临时紧急扩容</code>了，具体操作步骤和思路如下：</p><ul><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue。</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息。</li></ul><h2 id="mq-中的消息过期失效了"><a href="#mq-中的消息过期失效了" class="headerlink" title="mq 中的消息过期失效了"></a>mq 中的消息过期失效了</h2><p>假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是<strong>大量的数据会直接搞丢</strong>。</p><p>这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是<strong>批量重导</strong>，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。</p><p>假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。</p><h2 id="mq-都快写满了"><a href="#mq-都快写满了" class="headerlink" title="mq 都快写满了"></a>mq 都快写满了</h2><p>如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，<strong>消费一个丢弃一个，都不要了</strong>，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何设计一个消息队列？</title>
      <link href="/posts/8e7ae4b7.html"/>
      <url>/posts/8e7ae4b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何设计一个消息队列？"><a href="#如何设计一个消息队列？" class="headerlink" title="如何设计一个消息队列？"></a>如何设计一个消息队列？</h1><p>其实聊到这个问题，一般面试官要考察两块：</p><ul><li>你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个消息队列的架构原理。</li><li>看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。</li></ul><p>说实话，问类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，<strong>大多数人就是平时埋头用，从来不去思考背后的一些东西</strong>。类似的问题，比如，如果让你来设计一个 Spring 框架你会怎么做？如果让你来设计一个 Dubbo 框架你会怎么做？如果让你来设计一个 MyBatis 框架你会怎么做？</p><p>其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。</p><p>比如说这个消息队列系统，我们从以下几个角度来考虑一下：</p><ul><li>首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</li><li>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</li><li>其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</li><li>能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。</li></ul><p>mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何保证消息的顺序性？</title>
      <link href="/posts/a8a4f08c.html"/>
      <url>/posts/a8a4f08c.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何保证消息的顺序性？"><a href="#如何保证消息的顺序性？" class="headerlink" title="如何保证消息的顺序性？"></a>如何保证消息的顺序性？</h1><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>我举个例子，我们以前做过一个 mysql <code>binlog</code> 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -&gt; mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。</p><p>你在 mysql 里增删改一条数据，对应出来了增删改 3 条 <code>binlog</code> 日志，接着这三条 <code>binlog</code> 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你愣是换了顺序给执行成删除、修改、增加，不全错了么。</p><p>本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。</p><p>先看看顺序会错乱的俩场景：</p><ul><li><strong>RabbitMQ</strong>：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1&#x2F;data2&#x2F;data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者 2 先执行完操作，把 data2 存入数据库，然后是 data1&#x2F;data3。这不明显乱了。</li></ul><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gj40w75c6ej30re0rgabz.jpg" alt="image-20200926141206052" style="zoom: 50%;" /><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li><strong>Kafka</strong>：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。<br>消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞<strong>多个线程来并发处理消息</strong>。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。</li></ul><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/kafka-order-01.png" alt="kafka-order-01" style="zoom:67%;" /><hr><p>解决方法：</p><h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。</p><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/rabbitmq-order-02.png" alt="rabbitmq-order-02" style="zoom:67%;" /><h2 id="Kafka-1"><a href="#Kafka-1" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li>一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。</li><li>写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。</li></ul><img src="https://doocs.gitee.io/advanced-java/docs/high-concurrency/images/kafka-order-02.png" alt="kafka-order-02" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性Stream</title>
      <link href="/posts/6887151b.html"/>
      <url>/posts/6887151b.html</url>
      
        <content type="html"><![CDATA[<h1 id="流和集合"><a href="#流和集合" class="headerlink" title="流和集合"></a>流和集合</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="集合，例如List、Set、Tree等，是一种存储数据的数据结构。关于数据，是已经存在了的，我们只是通过一种数据结构将数据组织起来，便于某种方式读取或保持某种结构"><a href="#集合，例如List、Set、Tree等，是一种存储数据的数据结构。关于数据，是已经存在了的，我们只是通过一种数据结构将数据组织起来，便于某种方式读取或保持某种结构" class="headerlink" title="集合，例如List、Set、Tree等，是一种存储数据的数据结构。关于数据，是已经存在了的，我们只是通过一种数据结构将数据组织起来，便于某种方式读取或保持某种结构"></a>集合，例如List、Set、Tree等，是一种存储数据的数据结构。关于数据，是已经存在了的，我们只是通过一种数据结构将数据组织起来，便于某种方式读取或保持某种结构</h3><h3 id="流不同于集合的地方在于数据并非在使用前全部获得，而是在使用过程中按需获得"><a href="#流不同于集合的地方在于数据并非在使用前全部获得，而是在使用过程中按需获得" class="headerlink" title="流不同于集合的地方在于数据并非在使用前全部获得，而是在使用过程中按需获得"></a>流不同于集合的地方在于数据并非在使用前全部获得，而是在使用过程中按需获得</h3><h3 id="所以虽然我们都能从集合、流中获取数据，但数据产生的时间是有区别的，集合的数据是预先产生的，而流则是根据需要实时产生的。两者的特性也导致用途上的差异，集合侧重存储，流侧重计算。因此我们常听到的流式计算的叫法。"><a href="#所以虽然我们都能从集合、流中获取数据，但数据产生的时间是有区别的，集合的数据是预先产生的，而流则是根据需要实时产生的。两者的特性也导致用途上的差异，集合侧重存储，流侧重计算。因此我们常听到的流式计算的叫法。" class="headerlink" title="所以虽然我们都能从集合、流中获取数据，但数据产生的时间是有区别的，集合的数据是预先产生的，而流则是根据需要实时产生的。两者的特性也导致用途上的差异，集合侧重存储，流侧重计算。因此我们常听到的流式计算的叫法。"></a>所以虽然我们都能从集合、流中获取数据，但数据产生的时间是有区别的，集合的数据是<strong>预先产生</strong>的，而流则是根据需要<strong>实时产生</strong>的。两者的特性也导致用途上的差异，<strong>集合侧重存储</strong>，<strong>流侧重计算</strong>。因此我们常听到的流式计算的叫法。</h3><h3 id="集合，可以随时取用，但流在创建后只能被使用一次，若重复消费，则会报错。"><a href="#集合，可以随时取用，但流在创建后只能被使用一次，若重复消费，则会报错。" class="headerlink" title="集合，可以随时取用，但流在创建后只能被使用一次，若重复消费，则会报错。"></a>集合，可以随时取用，但<strong>流在创建后只能被使用一次</strong>，若重复消费，则会报错。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line">stream.forEach(System.out::print);</span><br><span class="line">stream.forEach(System.out::print);</span><br><span class="line"><span class="comment">// ABC</span></span><br><span class="line"><span class="comment">// java.lang.IllegalStateException: stream has already been operated upon or closed</span></span><br></pre></td></tr></table></figure><h2 id="创建流"><a href="#创建流" class="headerlink" title="创建流"></a>创建流</h2><h3 id="Collection的默认方法stream-，可以由集合类创建流。"><a href="#Collection的默认方法stream-，可以由集合类创建流。" class="headerlink" title="Collection的默认方法stream()，可以由集合类创建流。"></a><code>Collection</code>的默认方法<code>stream()</code>，可以由集合类创建流。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br></pre></td></tr></table></figure><h3 id="Stream的静态方法of-T-values-，通过显示值创建流，可接受任意数量的参数。"><a href="#Stream的静态方法of-T-values-，通过显示值创建流，可接受任意数量的参数。" class="headerlink" title="Stream的静态方法of(T... values)，通过显示值创建流，可接受任意数量的参数。"></a><code>Stream</code>的静态方法<code>of(T... values)</code>，通过显示值创建流，可接受任意数量的参数。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Arrays的静态方法stream-T-array-从数组创建流，接受一个数组参数。"><a href="#Arrays的静态方法stream-T-array-从数组创建流，接受一个数组参数。" class="headerlink" title="Arrays的静态方法stream(T[] array)从数组创建流，接受一个数组参数。"></a><code>Arrays</code>的静态方法<code>stream(T[] array)</code>从数组创建流，接受一个数组参数。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] ss = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; stream = Arrays.stream(ss);</span><br></pre></td></tr></table></figure><h3 id="NIO中有较多静态方法创建流，例如Files的静态方法lines-Path-path-从返回指定文件中的各行构成的字符串流。"><a href="#NIO中有较多静态方法创建流，例如Files的静态方法lines-Path-path-从返回指定文件中的各行构成的字符串流。" class="headerlink" title="NIO中有较多静态方法创建流，例如Files的静态方法lines(Path path)从返回指定文件中的各行构成的字符串流。"></a>NIO中有较多静态方法创建流，例如<code>Files</code>的静态方法<code>lines(Path path)</code>从返回指定文件中的各行构成的字符串流。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Stream&lt;String&gt; stream = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>))) &#123;</span><br><span class="line">    stream.forEach(System.out::print);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Stream的静态iterate和generate可根据函数计算创建无限流"><a href="#Stream的静态iterate和generate可根据函数计算创建无限流" class="headerlink" title="Stream的静态iterate和generate可根据函数计算创建无限流"></a><code>Stream</code>的静态<code>iterate</code>和<code>generate</code>可根据函数计算创建<strong>无限流</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; <span class="title function_">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span><br></pre></td></tr></table></figure><h2 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h2><p>流的操作分为两种：</p><ul><li><strong>中间操作</strong>：返回一个Stream对象，可以将一系列中间操作构成一条流的流水线（类似构造器模式）</li><li><strong>终端操作</strong>：执行流水线，返回不是流的结果（也可是void）</li></ul><p>这里的<code>filter</code>、<code>sorted</code>、<code>map</code>就是中间操作，<code>collect</code>为终端操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getFailedPaperStudentNamesByJava8</span><span class="params">(List&lt;Paper&gt; papers)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> papers.parallelStream()</span><br><span class="line">        .filter(p -&gt; p.getClassName().equals(<span class="string">&quot;语文&quot;</span>)  <span class="comment">// Stream&lt;Paper&gt;</span></span><br><span class="line">                &amp;&amp; p.getScore() &lt; <span class="number">60</span>)</span><br><span class="line">        .sorted((p1, p2) -&gt; p2.getScore() - p1.getScore())  <span class="comment">// Stream&lt;Paper&gt;</span></span><br><span class="line">        .map(Paper::getStudentName)  <span class="comment">// Stream&lt;String&gt;</span></span><br><span class="line">        .collect(Collectors.toList()); <span class="comment">// List&lt;String&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><ul><li>接受一个谓词Predicate（T -&gt; boolean）</li><li>返回一个包含所有符合谓词的元素的流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;AA&quot;</span>, <span class="string">&quot;AB&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .filter(s -&gt; s.startsWith(<span class="string">&quot;A&quot;</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// AA</span></span><br><span class="line"><span class="comment">// AB</span></span><br></pre></td></tr></table></figure><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a><strong>distinct</strong></h4><ul><li>根据流中元素的hashCode和equals方法比较元素</li><li>返回一个元素各异的流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::print);</span><br><span class="line"><span class="comment">// AB</span></span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a><strong>limit</strong></h4><ul><li>接受一个长度</li><li>返回一个不超过给定长度的流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .limit(<span class="number">2</span>)</span><br><span class="line">    .forEach(System.out::print);</span><br><span class="line"><span class="comment">// AB</span></span><br></pre></td></tr></table></figure><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a><strong>skip</strong></h4><ul><li>指定跳过前n个元素</li><li>如果元素不足n个，返回一个空流</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .skip(<span class="number">2</span>)</span><br><span class="line">    .forEach(System.out::print);</span><br><span class="line"><span class="comment">// C</span></span><br></pre></td></tr></table></figure><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>对每个元素应用函数</p><ul><li>接受一个函数（T -&gt; R）</li><li>将每一个元素映射成一个新的元素</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Paper&gt; papers = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;语文&quot;</span>, <span class="number">40</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;语文&quot;</span>, <span class="number">80</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小蓝&quot;</span>, <span class="string">&quot;语文&quot;</span>, <span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line">papers.stream()</span><br><span class="line">    .map(Paper::getStudentName)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">// 小明</span></span><br><span class="line"><span class="comment">// 小红</span></span><br><span class="line"><span class="comment">// 小蓝</span></span><br></pre></td></tr></table></figure><h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a><strong>flatMap</strong></h4><p>流的扁平化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;ABC&quot;</span>, <span class="string">&quot;DEF&quot;</span>, <span class="string">&quot;GHI&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; s.split(<span class="string">&quot;&quot;</span>)) <span class="comment">// Stream&lt;String[]&gt;</span></span><br><span class="line">    .forEach(System.out::println); </span><br><span class="line"><span class="comment">// [Ljava.lang.String;@2f4d3709</span></span><br><span class="line"><span class="comment">// [Ljava.lang.String;@4e50df2e</span></span><br><span class="line"><span class="comment">// [Ljava.lang.String;@1d81eb93</span></span><br></pre></td></tr></table></figure><h3 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h3><h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a><strong>anyMatch</strong></h4><ul><li>接受一个谓词（T -&gt; boolean）</li><li>如果有一个元素匹配，返回true，否则返回false</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.print(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;)</span><br><span class="line">    .anyMatch(s -&gt; s.startsWith(<span class="string">&quot;B&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// AB</span></span><br></pre></td></tr></table></figure><h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a><strong>allMatch</strong></h4><ul><li>接受一个谓词（T -&gt; boolean）</li><li>所有所有元素匹配，返回true，否则返回false</li><li>当有一个元素不匹配，就会短路返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;)</span><br><span class="line">    .allMatch(s -&gt; s.startsWith(<span class="string">&quot;B&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// A</span></span><br></pre></td></tr></table></figure><h4 id="nonMatch"><a href="#nonMatch" class="headerlink" title="nonMatch"></a><strong>nonMatch</strong></h4><p>所有元素不匹配</p><ul><li>接受一个谓词（T -&gt; boolean）</li><li>所有元素匹配，返回true，否则返回false</li><li>当有一个元素匹配，就会短路返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">list.stream()</span><br><span class="line">    .map(s -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;)</span><br><span class="line">    .noneMatch(s -&gt; s.startsWith(<span class="string">&quot;B&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// A</span></span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a><strong>findAny</strong></h4><p>返回当前流中的任意元素，用Optional封装元素，迫使显示检查元素是否存在。</p><h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a><strong>findFirst</strong></h4><p>返回当前流中的第一个元素</p><h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有初始值</span></span><br><span class="line">T <span class="title function_">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line"><span class="comment">// 无初始值</span></span><br><span class="line">Optional&lt;T&gt; <span class="title function_">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span>    </span><br></pre></td></tr></table></figure><p>通过接收一个BinaryOperator<code>(T, T) -&gt; T</code>，将两个元素结合产生一个新值。reduce将一直执行该操作直到最后流中只剩一个元素返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).reduce(<span class="number">0</span>, Integer::sum); <span class="comment">// 15</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> IntStream.of(nums).reduce(Integer::max).orElse(-<span class="number">1</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> IntStream.of(nums).reduce(Integer::min).orElse(-<span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h2 id="数值流的特殊操作"><a href="#数值流的特殊操作" class="headerlink" title="数值流的特殊操作"></a>数值流的特殊操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> IntStream.of(nums).sum(); <span class="comment">// 15，等同reduce(0, Integer::sum)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> IntStream.of(nums).max().orElse(-<span class="number">1</span>); <span class="comment">// 5，等同reduce(Integer::max).orElse(-1)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> IntStream.of(nums).min().orElse(-<span class="number">1</span>); <span class="comment">// 1，等同reduce(Integer::min).orElse(-1)</span></span><br><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> IntStream.of(nums).average().orElse(-<span class="number">1</span>); <span class="comment">//3.0</span></span><br></pre></td></tr></table></figure><h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><p><code>collect</code>在前面的示例中已经见过了，可以将流中的元素进行汇总。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);</span><br></pre></td></tr></table></figure><p>接收一个Collector收集器。在Collectors中已经内置了一些常用的收集器。</p><ul><li><code>toList()</code>：将元素收集成一个List。</li><li><code>toSet()</code>：将元素收集成一个Set。</li><li><code>counting()</code>：统计元素数量。</li><li><code>maxBy(Comparator&lt;? super T&gt; comparator)</code>：获取元素中的最大值。</li><li><code>minBy(Comparator&lt;? super T&gt; comparator)</code>：获取元素中的最小值。</li><li><code>summingInt(ToIntFunction&lt;? super T&gt; mapper)</code>：将元素映射成一个int值，然后求和，类似的还有double和long。</li><li><code>averagingInt(ToIntFunction&lt;? super T&gt; mapper)</code>：将元素映射成一个int值，然后求平均。</li><li><code>summarizingInt(ToIntFunction&lt;? super T&gt; mapper)</code>：将元素映射成一个int值，然后得到一个<code>IntSummaryStatistics</code>对象，包含了统计数、总和、最大值、最小值和平均值。</li><li><code>joining()</code>：把元素toSting()的结果连接成一个字符串，还有一个重载版本，接收一个分隔符参数。</li><li><code>groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：接收一个<code>Function</code>，返回一个<code>Map&lt;K, List&lt;T&gt;&gt;</code>。通过Function的返回值作为Key，然后将具有相同Key的元素，组合成List。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Paper&gt; papers = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;语文&quot;</span>, <span class="number">40</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小明&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="number">80</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;语文&quot;</span>, <span class="number">80</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小红&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="number">80</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小蓝&quot;</span>, <span class="string">&quot;语文&quot;</span>, <span class="number">50</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Paper</span>(<span class="string">&quot;小蓝&quot;</span>, <span class="string">&quot;数学&quot;</span>, <span class="number">60</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 所有语文卷子</span></span><br><span class="line">List&lt;Paper&gt; chinesePapers = papers.stream()</span><br><span class="line">    .filter(p -&gt; p.getClassName().equals(<span class="string">&quot;语文&quot;</span>))</span><br><span class="line">    .collect(toList());</span><br><span class="line"><span class="comment">// 所有学科</span></span><br><span class="line">Set&lt;String&gt; classNames = papers.stream()</span><br><span class="line">    .map(Paper::getClassName)</span><br><span class="line">    .collect(toSet());</span><br><span class="line"><span class="comment">// 最高分的卷子，最低分改成minBy就行</span></span><br><span class="line"><span class="type">Paper</span> <span class="variable">maxScorePaper</span> <span class="operator">=</span> papers.stream()</span><br><span class="line">    .collect(maxBy((p1, p2) -&gt; p1.getScore() - p2.getScore())).get();</span><br><span class="line"><span class="comment">// 总分数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sumScore</span> <span class="operator">=</span> papers.stream()</span><br><span class="line">    .collect(summingInt(Paper::getScore));</span><br><span class="line"><span class="comment">// 平均分</span></span><br><span class="line"><span class="type">double</span> <span class="variable">avgScore</span> <span class="operator">=</span> papers.stream()</span><br><span class="line">    .collect(averagingInt(Paper::getScore));</span><br><span class="line"><span class="comment">// 统计数、总和、最大值、最小值和平均值</span></span><br><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">summaryStatistics</span> <span class="operator">=</span> papers.stream()</span><br><span class="line">    .collect(summarizingInt(Paper::getScore));</span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> summaryStatistics.getCount();</span><br><span class="line"><span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> summaryStatistics.getSum();</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> summaryStatistics.getMax();</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> summaryStatistics.getMin();</span><br><span class="line"><span class="type">double</span> <span class="variable">avg</span> <span class="operator">=</span> summaryStatistics.getAverage();</span><br><span class="line"><span class="comment">// 学生名字连接在一起</span></span><br><span class="line"><span class="type">String</span> <span class="variable">studentNameStr</span> <span class="operator">=</span> papers.stream()</span><br><span class="line">    .map(Paper::getStudentName)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line"><span class="comment">// 按学科将卷子分组</span></span><br><span class="line">Map&lt;String, List&lt;Paper&gt;&gt; groupPapers = papers.stream()</span><br><span class="line">    .collect(groupingBy(Paper::getClassName));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性Stream---Filter</title>
      <link href="/posts/23dc1fa1.html"/>
      <url>/posts/23dc1fa1.html</url>
      
        <content type="html"><![CDATA[<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><h2 id="Filter-1"><a href="#Filter-1" class="headerlink" title="Filter"></a>Filter</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudSuicicrjavD8zvRricxoibmib2lS7AjCBczfquoKhbZkV07XvT5qVP8TiakzHCKncoQLQdTf1ib59qyHIQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><ul><li>遍历数据并检查其中的元素时使用。</li><li>filter接受一个函数作为参数，该函数用Lambda表达式表示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤所有的男性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fiterSex</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//old</span></span><br><span class="line">        List&lt;PersonModel&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (PersonModel person:data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;男&quot;</span>.equals(person.getSex()))&#123;</span><br><span class="line">                temp.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(temp);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//new</span></span><br><span class="line">        List&lt;PersonModel&gt; collect = data</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(person -&gt; <span class="string">&quot;男&quot;</span>.equals(person.getSex()))</span><br><span class="line">                .collect(toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过滤所有的男性 并且小于20岁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fiterSexAndAge</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//old</span></span><br><span class="line">        List&lt;PersonModel&gt; temp=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (PersonModel person:data) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;男&quot;</span>.equals(person.getSex())&amp;&amp;person.getAge()&lt;<span class="number">20</span>)&#123;</span><br><span class="line">                temp.add(person);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new 1</span></span><br><span class="line">        List&lt;PersonModel&gt; collect = data</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(person -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;男&quot;</span>.equals(person.getSex())&amp;&amp;person.getAge()&lt;<span class="number">20</span>)&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(toList());</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//new 2</span></span><br><span class="line">        List&lt;PersonModel&gt; collect1 = data</span><br><span class="line">                .stream()</span><br><span class="line">                .filter(person -&gt; (<span class="string">&quot;男&quot;</span>.equals(person.getSex())&amp;&amp;person.getAge()&lt;<span class="number">20</span>))</span><br><span class="line">                .collect(toList());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性Stream---Map</title>
      <link href="/posts/c203e0e4.html"/>
      <url>/posts/c203e0e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudSuicicrjavD8zvRricxoibmib2Qiaz1TAZOwCMyEnB8m9uqn4eGkLE4WMKe6AA1icq83RqRDmuchiaaxnLw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><ul><li>map生成的是个一对一映射,for的作用</li><li>比较常用</li><li>而且很简单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 取出所有的用户名字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">getUserNameList</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//old</span></span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (PersonModel persion:data) &#123;</span><br><span class="line">            list.add(persion.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new 1</span></span><br><span class="line">        List&lt;String&gt; collect = data.stream().map(person -&gt; person.getName()).collect(toList());</span><br><span class="line">        System.out.println(collect);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new 2</span></span><br><span class="line">        List&lt;String&gt; collect1 = data.stream().map(PersonModel::getName).collect(toList());</span><br><span class="line">        System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//new 3</span></span><br><span class="line">        List&lt;String&gt; collect2 = data.stream().map(person -&gt; &#123;</span><br><span class="line">            System.out.println(person.getName());</span><br><span class="line">            <span class="keyword">return</span> person.getName();</span><br><span class="line">        &#125;).collect(toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性Stream---FlatMap</title>
      <link href="/posts/dc19d218.html"/>
      <url>/posts/dc19d218.html</url>
      
        <content type="html"><![CDATA[<h1 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h1><h2 id="FlatMap-1"><a href="#FlatMap-1" class="headerlink" title="FlatMap"></a>FlatMap</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/eQPyBffYbudSuicicrjavD8zvRricxoibmib2mTH0ZwA7Q9cD92mDgOW4EibkPtjibI0OiaaDr3Wqrl3le9GJUHa6X3zwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p><p>顾名思义，跟map差不多,更深层次的操作，但还是有区别的</p><p><strong>map和flat返回值不同</strong></p><p>Map 每个输入元素，都按照规则转换成为另外一个元素。</p><p>还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><ul><li>Map一对一</li><li>Flatmap一对多</li></ul><p>map和flatMap的方法声明是不一样的</p><ul><li><r> Stream<r> map(Function mapper);</li><li><r> Stream<r> flatMap(Function&gt; mapper);</li></ul><p>map和flatMap的区别：我个人认为，flatMap的可以处理更深层次的数据，入参为多个list，结果可以返回为一个list，而map是一对一的，入参是多个list，结果返回必须是多个list。通俗的说，如果入参都是对象，那么flatMap可以操作对象里面的对象，而map只能操作第一层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">flatMapString</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">        <span class="comment">//返回类型不一样</span></span><br><span class="line">        List&lt;String&gt; collect = data.stream()</span><br><span class="line">                .flatMap(person -&gt; Arrays.stream(person.getName().split(<span class="string">&quot; &quot;</span>))).collect(toList());</span><br><span class="line"></span><br><span class="line">        List&lt;Stream&lt;String&gt;&gt; collect1 = data.stream()</span><br><span class="line">                .map(person -&gt; Arrays.stream(person.getName().split(<span class="string">&quot; &quot;</span>))).collect(toList());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用map实现</span></span><br><span class="line">        List&lt;String&gt; collect2 = data.stream()</span><br><span class="line">                .map(person -&gt; person.getName().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">                .flatMap(Arrays::stream).collect(toList());</span><br><span class="line">        <span class="comment">//另一种方式</span></span><br><span class="line">        List&lt;String&gt; collect3 = data.stream()</span><br><span class="line">                .map(person -&gt; person.getName().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">                .flatMap(str -&gt; Arrays.asList(str).stream()).collect(toList());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性Stream---Collect</title>
      <link href="/posts/668d8513.html"/>
      <url>/posts/668d8513.html</url>
      
        <content type="html"><![CDATA[<h1 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a>Collect</h1><h2 id="Collect-1"><a href="#Collect-1" class="headerlink" title="Collect"></a>Collect</h2><ul><li>collect在流中生成列表，map，等常用的数据结构</li><li>toList()</li><li>toSet()</li><li>toMap()</li><li>自定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * toList</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toListTest</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">       List&lt;String&gt; collect = data.stream()</span><br><span class="line">               .map(PersonModel::getName)</span><br><span class="line">               .collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * toSet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toSetTest</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">       Set&lt;String&gt; collect = data.stream()</span><br><span class="line">               .map(PersonModel::getName)</span><br><span class="line">               .collect(Collectors.toSet());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * toMap</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toMapTest</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">       Map&lt;String, Integer&gt; collect = data.stream()</span><br><span class="line">               .collect(</span><br><span class="line">                       Collectors.toMap(PersonModel::getName, PersonModel::getAge)</span><br><span class="line">               );</span><br><span class="line"></span><br><span class="line">       data.stream()</span><br><span class="line">               .collect(Collectors.toMap(per-&gt;per.getName(), value-&gt;&#123;</span><br><span class="line">           <span class="keyword">return</span> value+<span class="string">&quot;1&quot;</span>;</span><br><span class="line">       &#125;));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 指定类型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toTreeSetTest</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">       TreeSet&lt;PersonModel&gt; collect = data.stream()</span><br><span class="line">               .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">       System.out.println(collect);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toGroupTest</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">       Map&lt;Boolean, List&lt;PersonModel&gt;&gt; collect = data.stream()</span><br><span class="line">               .collect(Collectors.groupingBy(per -&gt; <span class="string">&quot;男&quot;</span>.equals(per.getSex())));</span><br><span class="line">       System.out.println(collect);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分隔</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">toJoiningTest</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">       <span class="type">String</span> <span class="variable">collect</span> <span class="operator">=</span> data.stream()</span><br><span class="line">               .map(personModel -&gt; personModel.getName())</span><br><span class="line">               .collect(Collectors.joining(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;&#123;&quot;</span>, <span class="string">&quot;&#125;&quot;</span>));</span><br><span class="line">       System.out.println(collect);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 自定义</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reduce</span><span class="params">()</span>&#123;</span><br><span class="line">       List&lt;String&gt; collect = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>).collect(</span><br><span class="line">               Collectors.reducing(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(), x -&gt; Arrays.asList(x), (y, z) -&gt; &#123;</span><br><span class="line">                   y.addAll(z);</span><br><span class="line">                   <span class="keyword">return</span> y;</span><br><span class="line">               &#125;));</span><br><span class="line">       System.out.println(collect);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性Stream---Optional</title>
      <link href="/posts/a3526d68.html"/>
      <url>/posts/a3526d68.html</url>
      
        <content type="html"><![CDATA[<h1 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h1><h2 id="Optional-1"><a href="#Optional-1" class="headerlink" title="Optional"></a>Optional</h2><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ginyb445nzj31170u0n50.jpg" alt="image-20200912163336611" style="zoom:40%;" /><ul><li>Optional 是为核心类库新设计的一个数据类型，用来替换 null 值。</li><li>人们对原有的 null 值有很多抱怨，甚至连发明这一概念的Tony Hoare也是如此，他曾说这是自己的一个“价值连城的错误”</li><li>用处很广，不光在lambda中，哪都能用</li><li>Optional.of(T)，T为非空，否则初始化报错</li><li>Optional.ofNullable(T)，T为任意，可以为空</li><li>isPresent()，相当于 ！&#x3D;null</li><li>ifPresent(T)， T可以是一段lambda表达式 ，或者其他代码，非空则执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        PersonModel personModel=<span class="keyword">new</span> <span class="title class_">PersonModel</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象为空则打出 -</span></span><br><span class="line">        Optional&lt;Object&gt; o = Optional.of(personModel);</span><br><span class="line">        System.out.println(o.isPresent()?o.get():<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//名称为空则打出 -</span></span><br><span class="line">        Optional&lt;String&gt; name = Optional.ofNullable(personModel.getName());</span><br><span class="line">        System.out.println(name.isPresent()?name.get():<span class="string">&quot;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不为空，则打出xxx</span></span><br><span class="line">        Optional.ofNullable(<span class="string">&quot;test&quot;</span>).ifPresent(na-&gt;&#123;</span><br><span class="line">            System.out.println(na+<span class="string">&quot;ifPresent&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果空，则返回指定字符串</span></span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="literal">null</span>).orElse(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="string">&quot;1&quot;</span>).orElse(<span class="string">&quot;-&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果空，则返回 指定方法，或者代码</span></span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="literal">null</span>).orElseGet(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hahah&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="string">&quot;1&quot;</span>).orElseGet(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;hahah&quot;</span>;</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果空，则可以抛出异常</span></span><br><span class="line">        System.out.println(Optional.ofNullable(<span class="string">&quot;1&quot;</span>).orElseThrow(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ss&quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Objects.requireNonNull(null,&quot;is null&quot;);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//利用 Optional 进行多级判断</span></span><br><span class="line">        <span class="type">EarthModel</span> <span class="variable">earthModel1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EarthModel</span>();</span><br><span class="line">        <span class="comment">//old</span></span><br><span class="line">        <span class="keyword">if</span> (earthModel1!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (earthModel1.getTea()!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//new</span></span><br><span class="line">        Optional.ofNullable(earthModel1)</span><br><span class="line">                .map(EarthModel::getTea)</span><br><span class="line">                .map(TeaModel::getType)</span><br><span class="line">                .isPresent();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Optional&lt;EarthModel&gt; earthModel = Optional.ofNullable(new EarthModel());</span></span><br><span class="line"><span class="comment">//        Optional&lt;List&lt;PersonModel&gt;&gt; personModels = earthModel.map(EarthModel::getPersonModels);</span></span><br><span class="line"><span class="comment">//        Optional&lt;Stream&lt;String&gt;&gt; stringStream = personModels.map(per -&gt; per.stream().map(PersonModel::getName));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断对象中的list</span></span><br><span class="line">        Optional.ofNullable(<span class="keyword">new</span> <span class="title class_">EarthModel</span>())</span><br><span class="line">                .map(EarthModel::getPersonModels)</span><br><span class="line">                .map(pers-&gt;pers</span><br><span class="line">                        .stream()</span><br><span class="line">                        .map(PersonModel::getName)</span><br><span class="line">                        .collect(toList()))</span><br><span class="line">                .ifPresent(per-&gt; System.out.println(per));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        List&lt;PersonModel&gt; models=Data.getData();</span><br><span class="line">        Optional.ofNullable(models)</span><br><span class="line">                .map(per -&gt; per</span><br><span class="line">                        .stream()</span><br><span class="line">                        .map(PersonModel::getName)</span><br><span class="line">                        .collect(toList()))</span><br><span class="line">                .ifPresent(per-&gt; System.out.println(per));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stream </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
